<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Editor</title>
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#18181b">
  
    <style>
        * { box-sizing: border-box; }
        body {
            margin: 0;
            height: 100vh;
            background: #09090b;
            color: #e4e4e7;
            font-family: system-ui, -apple-system, sans-serif;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        .topbar {
            height: 52px;
            background: #18181b;
            border-bottom: 1px solid #27272a;
            display: flex;
            align-items: center;
            padding: 0 16px;
            gap: 12px;
            flex-shrink: 0;
        }
        
        .logo { font-weight: 700; font-size: 20px; letter-spacing: -0.5px; }
        
        .btn {
            background: #27272a;
            color: #e4e4e7;
            border: none;
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
            width: 100%;
            text-align: left;
        }
        .btn:hover { background: #3f3f46; }
        .btn.accent {
            background: #d4d4d8;
            color: black;
            font-weight: 600;
        }
        .btn.accent:hover { background: #e4e4e7; }
        
        .main { flex: 1; display: flex; overflow: hidden; }
        
        .sidebar {
            width: 280px;
            background: #111113;
            border-right: 1px solid #27272a;
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
            transition: width 0.2s, opacity 0.2s;
            overflow: hidden;
        }
        .sidebar.hidden {
            width: 0;
            border-right: none;
            opacity: 0;
            pointer-events: none;
        }

        .sidebar-buttons {
            display: flex;
            flex-direction: column;
            gap: 6px;
            padding: 12px;
            border-bottom: 1px solid #27272a;
        }
        
        .sidebar-header {
            padding: 12px 16px;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #71717a;
            border-bottom: 1px solid #27272a;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .tree-container {
            flex: 1;
            overflow-y: auto;
            padding: 8px 0;
            font-size: 13px;
        }
        
        .tree-folder { }
        
        .folder-header {
            padding: 4px 12px;
            display: flex;
            align-items: center;
            gap: 6px;
            cursor: pointer;
            user-select: none;
        }
        .folder-header:hover { background: #27272a; }
        
        .toggle {
            display: inline-block;
            width: 14px;
            font-size: 11px;
            color: #71717a;
        }
        
        .tree-children {
            padding-left: 20px;
        }
        
        .file-item {
            padding: 4px 12px 4px 32px;
            cursor: pointer;
            outline: none;
        }
        .file-item:hover, .file-item:focus { background: #27272a; }

        .folder-header:focus { background: #27272a; outline: none; }
        
        .editor-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 0;
        }
        
        .tabs {
            display: flex;
            background: #18181b;
            border-bottom: 1px solid #27272a;
            overflow-x: auto;
            flex-shrink: 0;
        }
        
        .tab {
            padding: 10px 20px 8px;
            white-space: nowrap;
            border-right: 1px solid #27272a;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            position: relative;
        }
        .tab.active {
            background: #09090b;
            border-bottom: 2px solid #a1a1aa;
        }
        .tab .close {
            margin-left: 12px;
            opacity: 0.6;
            font-size: 15px;
        }
        .tab .close:hover { opacity: 1; color: #e4e4e7; }
        .tab .dirty-indicator {
            color: #a1a1aa;
            font-size: 10px;
            margin-left: 2px;
        }
        
        .toast {
            position: fixed;
            top: 16px;
            left: 50%;
            transform: translateX(-50%);
            background: #27272a;
            color: #e4e4e7;
            padding: 10px 24px;
            border-radius: 8px;
            font-size: 13px;
            z-index: 9999;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
            animation: toast-in 0.3s ease;
            max-width: 80vw;
            word-break: break-word;
        }
        @keyframes toast-in {
            from { opacity: 0; transform: translateX(-50%) translateY(-12px); }
            to   { opacity: 1; transform: translateX(-50%) translateY(0); }
        }
        
        .editor-wrapper {
            flex: 1;
            display: flex;
            position: relative;
            background: #0a0a0b;
            overflow: hidden;
        }
        
        #gutter {
            width: 52px;
            background: #0f0f11;
            color: #52525b;
            text-align: right;
            padding: 12px 8px 0 0;
            user-select: none;
            font-family: ui-monospace, monospace;
            font-size: 14px;
            line-height: 1.6;
            overflow: hidden;
            border-right: 1px solid #1f1f22;
            flex-shrink: 0;
        }
        
        #textarea {
            flex: 1;
            background: transparent;
            border: none;
            outline: none;
            color: #e4e4e7;
            font-family: ui-monospace, monospace;
            font-size: 14px;
            line-height: 1.6;
            padding: 12px 16px;
            resize: none;
            overflow: auto;
            white-space: pre;
            tab-size: 4;
        }
        
        .status {
            height: 28px;
            background: #18181b;
            border-top: 1px solid #27272a;
            font-size: 12px;
            color: #52525b;
            display: flex;
            align-items: center;
            padding: 0 16px;
            font-family: ui-monospace, monospace;
        }

        .sidebar-toggle {
            background: none;
            border: none;
            color: #a1a1aa;
            font-size: 18px;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
        }
        .sidebar-toggle:hover { background: #27272a; color: #e4e4e7; }

        /* Search panel styles */
        .search-panel {
            position: fixed;
            top: 60px;
            right: 20px;
            background: #18181b;
            border: 1px solid #27272a;
            border-radius: 8px;
            padding: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
        }
        .search-panel input {
            background: #27272a;
            border: 1px solid #3f3f46;
            color: #e4e4e7;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 13px;
            outline: none;
            width: 200px;
        }
        .search-panel input:focus {
            border-color: #52525b;
        }
        .search-panel button {
            background: #27272a;
            border: none;
            color: #e4e4e7;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 13px;
            cursor: pointer;
        }
        .search-panel button:hover {
            background: #3f3f46;
        }
        .search-panel .match-count {
            font-size: 12px;
            color: #71717a;
        }
        .search-panel .close-search {
            background: none;
            border: none;
            color: #71717a;
            cursor: pointer;
            font-size: 18px;
            padding: 0 4px;
        }
        .search-panel .close-search:hover {
            color: #e4e4e7;
        }
    </style>
</head>
<body>
    <div class="topbar">
        <button class="sidebar-toggle" onclick="toggleSidebar()" title="Toggle Sidebar">☰</button>
        <div class="logo">Editor</div>
        
        <div style="flex:1"></div>
        <div id="status" class="status">Ready</div>
    </div>

    <div class="main">
        <!-- Sidebar with buttons and recursive tree -->
        <div id="sidebar" class="sidebar">
            <div class="sidebar-buttons">
                <button class="btn" onclick="openFolder()">Open Folder</button>
                <button class="btn" onclick="openFile()">Open File</button>
                <button class="btn" onclick="newFile()">New File</button>
                <button class="btn accent" onclick="saveCurrentFile()">Save (Ctrl+S)</button>
            </div>
            <div id="sidebar-header" class="sidebar-header">Directory</div>
            <div id="tree-container" class="tree-container"></div>
            <div style="padding:12px;border-top:1px solid #27272a;font-size:11px;color:#52525b;cursor:pointer" onclick="clearSavedFolder()">
                Clear saved folder
            </div>
        </div>

        <!-- Editor area -->
        <div class="editor-area">
            <div id="tabs" class="tabs"></div>
            
            <div class="editor-wrapper">
                <div id="gutter"></div>
                <textarea id="textarea" spellcheck="false" autocapitalize="none" autocomplete="off"></textarea>
            </div>
            
            <div id="editor-status" class="status">No file open</div>
        </div>
    </div>

    <script>
        // ═════════════════════════════════════════════════════════════
        // Core state
        // ═════════════════════════════════════════════════════════════
        let currentDirHandle = null;
        let fileTree = null;
        let tabs = [];
        let currentTabId = null;
        let nextTabId = 1; // FIXED: Better tab ID generation
        let db = null;
        let expandedFolders = new Set();

        const textarea = document.getElementById('textarea');
        const gutter = document.getElementById('gutter');
        const tabsContainer = document.getElementById('tabs');
        const treeContainer = document.getElementById('tree-container');
        const sidebarHeader = document.getElementById('sidebar-header');
        const sidebarEl = document.getElementById('sidebar');
        const statusEl = document.getElementById('status');
        const editorStatusEl = document.getElementById('editor-status');

        const TEXT_FILE_EXTENSIONS = /\.(txt|md|js|ts|html|css|json|py|go|rs|jsx|tsx|vue|xml|yaml|yml|toml|sh|bash|sql)$/i;
        const INVALID_FILENAME_CHARS = /[<>:"|?*\x00-\x1F]/g; // FIXED: Better filename validation

        function toggleSidebar() {
            sidebarEl.classList.toggle('hidden');
        }

        // ═════════════════════════════════════════════════════════════
        // Toast notifications
        // ═════════════════════════════════════════════════════════════
        function showToast(message, duration = 4000) {
            const toast = document.createElement('div');
            toast.className = 'toast';
            toast.textContent = message;
            document.body.appendChild(toast);
            setTimeout(() => toast.remove(), duration);
        }

        // ═════════════════════════════════════════════════════════════
        // IndexedDB + localStorage
        // ═════════════════════════════════════════════════════════════
        async function initDB() {
            return new Promise(resolve => {
                const req = indexedDB.open('FileEditor', 1);
                req.onupgradeneeded = e => e.target.result.createObjectStore('handles');
                req.onsuccess = e => { db = e.target.result; resolve(); };
                req.onerror = e => { 
                    console.error('IndexedDB error:', e);
                    resolve(); // Continue even if DB fails
                };
            });
        }

        async function saveFolderHandle(handle) {
            if (!db) await initDB();
            try {
                const tx = db.transaction('handles', 'readwrite');
                tx.objectStore('handles').put(handle, 'main');
            } catch (e) {
                console.error('Failed to save folder handle:', e);
            }
        }

        // FIXED: Added permission checks when loading saved folder
        async function loadSavedFolder() {
            if (!db) await initDB();
            try {
                const tx = db.transaction('handles');
                const store = tx.objectStore('handles');
                const request = store.get('main');
                
                request.onsuccess = async () => {
                    if (!request.result) return;
                    
                    const handle = request.result;
                    try {
                        // Check if handle still has permission
                        let permission = await handle.queryPermission({ mode: 'readwrite' });
                        
                        if (permission !== 'granted') {
                            permission = await handle.requestPermission({ mode: 'readwrite' });
                        }
                        
                        if (permission === 'granted') {
                            currentDirHandle = handle;
                            await buildAndRenderTree();
                        } else {
                            showToast('Permission denied for saved folder. Please re-open.');
                            await clearSavedFolder();
                        }
                    } catch (err) {
                        showToast('Saved folder no longer accessible');
                        await clearSavedFolder();
                    }
                };
                
                request.onerror = () => {
                    console.error('Failed to load saved folder');
                };
            } catch (e) {
                console.error('Error in loadSavedFolder:', e);
            }
        }

        function loadExpandedState() {
            try {
                const saved = localStorage.getItem('expandedFolders');
                if (saved) expandedFolders = new Set(JSON.parse(saved));
            } catch (e) {
                console.error('Failed to load expanded state:', e);
            }
        }

        function saveExpandedState() {
            try {
                localStorage.setItem('expandedFolders', JSON.stringify([...expandedFolders]));
            } catch (e) {
                console.error('Failed to save expanded state:', e);
            }
        }

        // ═════════════════════════════════════════════════════════════
        // File handle comparison - FIXED
        // ═════════════════════════════════════════════════════════════
        async function isSameEntry(h1, h2) {
            if (!h1 || !h2) return false;
            
            // Use native isSameEntry if available
            if (h1.isSameEntry) {
                try {
                    return await h1.isSameEntry(h2);
                } catch (e) {
                    console.error('isSameEntry failed:', e);
                }
            }
            
            // Fallback: compare file metadata
            try {
                const file1 = await h1.getFile();
                const file2 = await h2.getFile();
                return file1.name === file2.name && 
                       file1.size === file2.size && 
                       file1.lastModified === file2.lastModified;
            } catch {
                return false;
            }
        }

        // ═════════════════════════════════════════════════════════════
        // Recursive tree building with depth limit - FIXED
        // ═════════════════════════════════════════════════════════════
        async function buildTree(dirHandle, basePath = '', maxDepth = 10, currentDepth = 0) {
            const node = {
                name: dirHandle.name,
                kind: 'directory',
                handle: dirHandle,
                path: basePath,
                children: [],
                truncated: false
            };

            // Prevent infinite recursion on very deep directories
            if (currentDepth >= maxDepth) {
                node.truncated = true;
                return node;
            }

            try {
                for await (const [name, handle] of dirHandle.entries()) {
                    // Skip hidden files and common ignore patterns
                    if (name.startsWith('.') || name === 'node_modules' || name === '__pycache__') {
                        continue;
                    }

                    const childPath = basePath ? `${basePath}/${name}` : name;
                    
                    if (handle.kind === 'directory') {
                        const childNode = await buildTree(handle, childPath, maxDepth, currentDepth + 1);
                        node.children.push(childNode);
                    } else {
                        node.children.push({
                            name: name,
                            kind: 'file',
                            handle: handle,
                            path: childPath,
                            ext: name.split('.').pop().toLowerCase()
                        });
                    }
                }

                // Folders first, then alphabetical
                node.children.sort((a, b) => {
                    if (a.kind !== b.kind) return a.kind === 'directory' ? -1 : 1;
                    return a.name.localeCompare(b.name, undefined, { numeric: true });
                });
            } catch (err) {
                console.error('Error building tree:', err);
                showToast('Error reading directory: ' + dirHandle.name);
            }

            return node;
        }

        async function buildAndRenderTree() {
            if (!currentDirHandle) return;
            
            try {
                fileTree = await buildTree(currentDirHandle);
                sidebarHeader.textContent = `Directory: ${fileTree.name}`;
                renderTree();
            } catch (err) {
                showToast('Failed to build directory tree: ' + err.message);
            }
        }

        // ═════════════════════════════════════════════════════════════
        // Tree rendering
        // ═════════════════════════════════════════════════════════════
        function renderTree() {
            treeContainer.innerHTML = '';
            if (!fileTree) return;
            
            fileTree.children.forEach(child => {
                renderTreeItem(child, treeContainer, 0);
            });
        }

        function renderTreeItem(node, parentEl, level) {
            if (node.kind === 'directory') {
                const folderDiv = document.createElement('div');
                folderDiv.className = 'tree-folder';
                
                const header = document.createElement('div');
                header.className = 'folder-header';
                header.style.paddingLeft = `${level * 16}px`;
                header.tabIndex = 0;
                
                const toggle = document.createElement('span');
                toggle.className = 'toggle';
                toggle.textContent = expandedFolders.has(node.path) ? '▼' : '▶';
                
                header.appendChild(toggle);
                header.appendChild(document.createTextNode(' ' + node.name));
                
                if (node.truncated) {
                    const truncatedNote = document.createElement('span');
                    truncatedNote.style.color = '#71717a';
                    truncatedNote.style.fontSize = '11px';
                    truncatedNote.textContent = ' (depth limit)';
                    header.appendChild(truncatedNote);
                }
                
                const childrenDiv = document.createElement('div');
                childrenDiv.className = 'tree-children';
                childrenDiv.style.display = expandedFolders.has(node.path) ? 'block' : 'none';
                
                header.onclick = () => toggleFolder(node, header, childrenDiv);
                header.addEventListener('keydown', e => handleTreeKeydown(e, node, header, childrenDiv));
                
                folderDiv.appendChild(header);
                folderDiv.appendChild(childrenDiv);
                parentEl.appendChild(folderDiv);
                
                node.children.forEach(child => renderTreeItem(child, childrenDiv, level + 1));
            } else {
                const fileDiv = document.createElement('div');
                fileDiv.className = 'file-item';
                fileDiv.style.paddingLeft = `${level * 16 + 28}px`;
                fileDiv.textContent = node.name;
                fileDiv.tabIndex = 0;
                fileDiv.onclick = () => openFileFromNode(node);
                fileDiv.addEventListener('keydown', e => {
                    if (e.key === 'Enter') { e.preventDefault(); openFileFromNode(node); }
                    else navigateTree(e);
                });
                parentEl.appendChild(fileDiv);
            }
        }

        function toggleFolder(node, header, childrenDiv) {
            const isOpen = childrenDiv.style.display !== 'none';
            childrenDiv.style.display = isOpen ? 'none' : 'block';
            
            const toggle = header.querySelector('.toggle');
            toggle.textContent = isOpen ? '▶' : '▼';
            
            if (isOpen) {
                expandedFolders.delete(node.path);
            } else {
                expandedFolders.add(node.path);
            }
            saveExpandedState();
        }

        // ═════════════════════════════════════════════════════════════
        // Keyboard navigation in tree
        // ═════════════════════════════════════════════════════════════
        function getVisibleTreeItems() {
            return Array.from(treeContainer.querySelectorAll('.folder-header, .file-item'))
                .filter(el => el.offsetParent !== null);
        }

        function navigateTree(e) {
            const items = getVisibleTreeItems();
            const idx = items.indexOf(e.target);
            if (idx === -1) return;
            if (e.key === 'ArrowDown' && idx < items.length - 1) {
                e.preventDefault();
                items[idx + 1].focus();
            } else if (e.key === 'ArrowUp' && idx > 0) {
                e.preventDefault();
                items[idx - 1].focus();
            }
        }

        function handleTreeKeydown(e, node, header, childrenDiv) {
            if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                toggleFolder(node, header, childrenDiv);
            } else if (e.key === 'ArrowRight') {
                e.preventDefault();
                if (childrenDiv.style.display === 'none') {
                    toggleFolder(node, header, childrenDiv);
                } else {
                    const firstChild = childrenDiv.querySelector('.folder-header, .file-item');
                    if (firstChild) firstChild.focus();
                }
            } else if (e.key === 'ArrowLeft') {
                e.preventDefault();
                if (childrenDiv.style.display !== 'none') {
                    toggleFolder(node, header, childrenDiv);
                } else {
                    const parentChildren = header.closest('.tree-children');
                    if (parentChildren) {
                        const parentHeader = parentChildren.previousElementSibling;
                        if (parentHeader) parentHeader.focus();
                    }
                }
            } else {
                navigateTree(e);
            }
        }

        // ═════════════════════════════════════════════════════════════
        // File operations
        // ═════════════════════════════════════════════════════════════
        async function openFolder() {
            try {
                currentDirHandle = await window.showDirectoryPicker();
                await saveFolderHandle(currentDirHandle);
                expandedFolders.clear();
                await buildAndRenderTree();
            } catch (err) {
                if (err.name !== 'AbortError') {
                    showToast('Failed to open folder: ' + err.message);
                }
            }
        }

        async function openFile() {
            try {
                const [handle] = await window.showOpenFilePicker();
                const file = await handle.getFile();
                const content = await file.text();
                createNewTab(handle, file.name, content);
            } catch (err) {
                if (err.name !== 'AbortError') {
                    showToast('Failed to open file: ' + err.message);
                }
            }
        }

        async function newFile() {
            if (!currentDirHandle) {
                showToast('Open a folder first to create a new file.');
                return;
            }

            const name = prompt('Enter new file name:');
            if (!name || !name.trim()) return;

            const trimmed = name.trim();
            
            // FIXED: Better filename validation
            if (INVALID_FILENAME_CHARS.test(trimmed) || trimmed === '.' || trimmed === '..' || /[\/\\]/.test(trimmed)) {
                showToast('Invalid filename. Avoid special characters and path separators.');
                return;
            }

            try {
                // Check if file already exists
                let exists = false;
                try {
                    await currentDirHandle.getFileHandle(trimmed);
                    exists = true;
                } catch (e) { /* file does not exist */ }

                if (exists) {
                    showToast('A file with that name already exists.');
                    return;
                }

                const fileHandle = await currentDirHandle.getFileHandle(trimmed, { create: true });
                const writable = await fileHandle.createWritable();
                await writable.write('');
                await writable.close();

                createNewTab(fileHandle, trimmed, '');
                await buildAndRenderTree();
                statusEl.textContent = 'Created ' + trimmed;
                setTimeout(() => statusEl.textContent = 'Ready', 2000);
            } catch (err) {
                if (err.name !== 'AbortError') {
                    showToast('Failed to create file: ' + err.message);
                }
            }
        }

        async function openFileFromNode(node) {
            try {
                const file = await node.handle.getFile();
                if (!file.type.startsWith('text/') && !TEXT_FILE_EXTENSIONS.test(file.name)) {
                    if (!confirm('This looks like a binary file. Open anyway?')) return;
                }
                const content = await file.text();
                createNewTab(node.handle, node.name, content);
            } catch (err) {
                showToast('Failed to open file: ' + err.message);
            }
        }

        // ═════════════════════════════════════════════════════════════
        // Tabs & editor - FIXED: XSS protection, better ID generation
        // ═════════════════════════════════════════════════════════════
        async function createNewTab(handle, name, content = '') {
            // FIXED: Prevent duplicate tabs using proper handle comparison
            if (handle) {
                for (const t of tabs) {
                    if (t.handle && await isSameEntry(t.handle, handle)) {
                        switchToTab(t.id);
                        return;
                    }
                }
            }

            // FIXED: Better tab ID generation
            const id = nextTabId++;
            const tab = { id, name, handle, content, dirty: false };
            tabs.push(tab);
            
            const tabEl = document.createElement('div');
            tabEl.className = 'tab';
            tabEl.dataset.id = id;
            
            // FIXED: XSS-safe tab creation (no innerHTML with user content)
            const nameSpan = document.createElement('span');
            nameSpan.className = 'tab-name';
            nameSpan.textContent = name; // Safe - no HTML injection
            
            const dirtyIndicator = document.createElement('span');
            dirtyIndicator.className = 'dirty-indicator';
            dirtyIndicator.style.display = 'none';
            dirtyIndicator.textContent = ' *';
            
            const closeBtn = document.createElement('span');
            closeBtn.className = 'close';
            closeBtn.textContent = '×';
            closeBtn.onclick = (e) => { e.stopPropagation(); closeTab(id); };
            
            tabEl.appendChild(nameSpan);
            tabEl.appendChild(dirtyIndicator);
            tabEl.appendChild(closeBtn);
            tabEl.onclick = () => switchToTab(id);
            
            tabsContainer.appendChild(tabEl);
            tab.element = tabEl;
            
            switchToTab(id);
        }

        function switchToTab(id) {
            // FIXED: Sync content before switching to prevent data loss
            if (currentTabId !== null) {
                const current = tabs.find(t => t.id === currentTabId);
                if (current) {
                    current.content = textarea.value;
                }
            }
            
            currentTabId = id;
            const tab = tabs.find(t => t.id === id);
            
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelector(`.tab[data-id="${id}"]`)?.classList.add('active');
            
            textarea.value = tab.content;
            updateLineNumbers();
            updateEditorStatus(tab);
        }

        // FIXED: Warn about unsaved changes before closing
        function closeTab(id) {
            const idx = tabs.findIndex(t => t.id === id);
            if (idx === -1) return;
            
            const tab = tabs[idx];
            
            // Sync current content if this is the active tab
            if (currentTabId === id) {
                tab.content = textarea.value;
            }
            
            // Warn about unsaved changes
            if (tab.dirty) {
                if (!confirm(`"${tab.name}" has unsaved changes. Close anyway?`)) {
                    return;
                }
            }
            
            tabs.splice(idx, 1);
            const tabEl = document.querySelector(`.tab[data-id="${id}"]`);
            if (tabEl) tabEl.remove();
            
            if (tabs.length === 0) {
                currentTabId = null;
                textarea.value = '';
                gutter.innerHTML = '';
                editorStatusEl.textContent = 'No file open';
                return;
            }
            
            // Switch to nearest tab
            const nextIdx = Math.min(idx, tabs.length - 1);
            switchToTab(tabs[nextIdx].id);
        }

        function updateLineNumbers() {
            const lines = textarea.value.split('\n').length;
            let html = '';
            for (let i = 1; i <= lines; i++) html += i + '<br>';
            gutter.innerHTML = html;
        }

        function syncScroll() { 
            gutter.scrollTop = textarea.scrollTop; 
        }

        textarea.addEventListener('keydown', e => {
            if (e.key === 'Tab') {
                e.preventDefault();
                const start = textarea.selectionStart;
                const end = textarea.selectionEnd;
                textarea.value = textarea.value.substring(0, start) + '    ' + textarea.value.substring(end);
                textarea.selectionStart = textarea.selectionEnd = start + 4;
            }
        });

        // ═════════════════════════════════════════════════════════════
        // Auto-save with debouncing - FIXED: Sync content first
        // ═════════════════════════════════════════════════════════════
        let saveTimer;
        function scheduleSave() {
            clearTimeout(saveTimer);
            saveTimer = setTimeout(() => {
                if (currentTabId !== null) {
                    const tab = tabs.find(t => t.id === currentTabId);
                    if (tab && tab.dirty) {
                        // FIXED: Sync content before saving
                        tab.content = textarea.value;
                        saveCurrentFile();
                    }
                }
            }, 800);
        }

        textarea.addEventListener('input', () => {
            updateLineNumbers();
            if (currentTabId !== null) {
                const tab = tabs.find(t => t.id === currentTabId);
                if (tab) {
                    tab.dirty = true;
                    if (tab.element) {
                        const indicator = tab.element.querySelector('.dirty-indicator');
                        if (indicator) indicator.style.display = '';
                    }
                    updateEditorStatus(tab);
                    scheduleSave();
                }
            }
        });

        textarea.addEventListener('scroll', syncScroll);

        async function saveCurrentFile() {
            if (currentTabId === null) return;
            const tab = tabs.find(t => t.id === currentTabId);
            if (!tab || !tab.handle) return;
            if (!tab.dirty) return;
            
            try {
                const writable = await tab.handle.createWritable();
                await writable.write(textarea.value);
                await writable.close();
                tab.content = textarea.value;
                tab.dirty = false;
                if (tab.element) {
                    const indicator = tab.element.querySelector('.dirty-indicator');
                    if (indicator) indicator.style.display = 'none';
                }
                updateEditorStatus(tab);
                statusEl.textContent = 'Saved';
                setTimeout(() => statusEl.textContent = 'Ready', 1200);
            } catch (err) {
                showToast('Save failed: ' + err.message);
            }
        }

        function updateEditorStatus(tab) {
            editorStatusEl.textContent = tab.name + (tab.dirty ? ' • Modified' : '');
        }

        // ═════════════════════════════════════════════════════════════
        // Search functionality - NEW
        // ═════════════════════════════════════════════════════════════
        let searchPanel = null;
        let searchMatches = [];
        let currentMatchIndex = -1;

        function showSearchPanel() {
            if (searchPanel) {
                document.getElementById('search-input').focus();
                return;
            }

            searchPanel = document.createElement('div');
            searchPanel.className = 'search-panel';
            searchPanel.innerHTML = `
                <input type="text" id="search-input" placeholder="Search...">
                <span class="match-count" id="match-count">0 matches</span>
                <button onclick="findNext()">Next</button>
                <button onclick="findPrevious()">Previous</button>
                <button class="close-search" onclick="closeSearch()">×</button>
            `;
            document.body.appendChild(searchPanel);

            const input = document.getElementById('search-input');
            input.focus();
            input.addEventListener('input', performSearch);
            input.addEventListener('keydown', e => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    if (e.shiftKey) {
                        findPrevious();
                    } else {
                        findNext();
                    }
                } else if (e.key === 'Escape') {
                    closeSearch();
                }
            });
        }

        function performSearch() {
            const query = document.getElementById('search-input').value;
            searchMatches = [];
            currentMatchIndex = -1;

            if (!query || !textarea.value) {
                document.getElementById('match-count').textContent = '0 matches';
                return;
            }

            const text = textarea.value;
            const lowerText = text.toLowerCase();
            const lowerQuery = query.toLowerCase();
            
            let pos = 0;
            while ((pos = lowerText.indexOf(lowerQuery, pos)) !== -1) {
                searchMatches.push(pos);
                pos += query.length;
            }

            document.getElementById('match-count').textContent = `${searchMatches.length} matches`;
            
            if (searchMatches.length > 0) {
                currentMatchIndex = 0;
                highlightMatch();
            }
        }

        function findNext() {
            if (searchMatches.length === 0) return;
            currentMatchIndex = (currentMatchIndex + 1) % searchMatches.length;
            highlightMatch();
        }

        function findPrevious() {
            if (searchMatches.length === 0) return;
            currentMatchIndex = (currentMatchIndex - 1 + searchMatches.length) % searchMatches.length;
            highlightMatch();
        }

        function highlightMatch() {
            if (currentMatchIndex < 0 || currentMatchIndex >= searchMatches.length) return;
            
            const pos = searchMatches[currentMatchIndex];
            const query = document.getElementById('search-input').value;
            
            textarea.focus();
            textarea.setSelectionRange(pos, pos + query.length);
            textarea.scrollTop = textarea.scrollHeight * (pos / textarea.value.length) - textarea.clientHeight / 2;
            
            document.getElementById('match-count').textContent = 
                `${currentMatchIndex + 1} of ${searchMatches.length}`;
        }

        function closeSearch() {
            if (searchPanel) {
                searchPanel.remove();
                searchPanel = null;
                searchMatches = [];
                currentMatchIndex = -1;
            }
        }

        // ═════════════════════════════════════════════════════════════
        // Global keyboard shortcuts
        // ═════════════════════════════════════════════════════════════
        document.addEventListener('keydown', e => {
            // Save: Ctrl+S
            if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                e.preventDefault();
                saveCurrentFile();
            }
            // Search: Ctrl+F
            else if ((e.ctrlKey || e.metaKey) && e.key === 'f') {
                e.preventDefault();
                showSearchPanel();
            }
            // Close tab: Ctrl+W
            else if ((e.ctrlKey || e.metaKey) && e.key === 'w') {
                e.preventDefault();
                if (currentTabId !== null) {
                    closeTab(currentTabId);
                }
            }
        });

        async function clearSavedFolder() {
            if (db) {
                try {
                    const tx = db.transaction('handles', 'readwrite');
                    tx.objectStore('handles').delete('main');
                } catch (e) {
                    console.error('Failed to clear saved folder:', e);
                }
            }
            currentDirHandle = null;
            fileTree = null;
            treeContainer.innerHTML = '';
            sidebarHeader.textContent = 'Directory';
            expandedFolders.clear();
            localStorage.removeItem('expandedFolders');
            showToast('Saved folder cleared');
        }

        // ═════════════════════════════════════════════════════════════
        // Service worker registration
        // ═════════════════════════════════════════════════════════════
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('sw.js')
                .then(() => console.log('Service Worker registered'))
                .catch(err => console.log('SW registration failed', err));
        }

        // ═════════════════════════════════════════════════════════════
        // Initialization
        // ═════════════════════════════════════════════════════════════
        window.onload = async () => {
            await initDB();
            loadExpandedState();
            await loadSavedFolder();
            
            if (tabs.length === 0) {
                createNewTab(null, 'welcome.txt', 
                    'FileEditor is ready.\n\nKeyboard shortcuts:\n- Ctrl+S: Save current file\n- Ctrl+F: Search in file\n- Ctrl+W: Close current tab\n- Tab: Insert 4 spaces\n\nFixed in this version:\n✓ Permission checks on folder reload\n✓ Proper file handle comparison\n✓ XSS protection in tab names\n✓ Warning before closing unsaved tabs\n✓ Search functionality (Ctrl+F)\n✓ Better error handling\n✓ Depth limits on directory traversal\n');
            }
        };
    </script>
</body>
</html>
