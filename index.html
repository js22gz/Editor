<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EDITOR</title>
 
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#18181b">
    <style>
        * { box-sizing: border-box; }
        body {
            margin: 0;
            height: 100vh;
            background: #09090b;
            color: #e4e4e7;
            font-family: system-ui, -apple-system, sans-serif;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
     
        .topbar {
            height: 52px;
            background: #18181b;
            border-bottom: 1px solid #27272a;
            display: flex;
            align-items: center;
            padding: 0 16px;
            gap: 12px;
            flex-shrink: 0;
        }
     
        .logo { font-weight: 700; font-size: 20px; letter-spacing: -0.5px; }
     
        .btn {
            background: #27272a;
            color: #e4e4e7;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .btn:hover { background: #3f3f46; }
        .btn.accent {
            background: #d4d4d8;
            color: black;
            font-weight: 600;
        }
        .btn.accent:hover { background: #e4e4e7; }
     
        .main { flex: 1; display: flex; overflow: hidden; }
     
        .sidebar {
            width: 280px;
            background: #111113;
            border-right: 1px solid #27272a;
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
            transition: width 0.2s, opacity 0.2s;
            overflow: hidden;
        }
        .sidebar.hidden {
            width: 0;
            border-right: none;
            opacity: 0;
            pointer-events: none;
        }
        .sidebar-buttons {
            display: flex;
            flex-direction: column;
            gap: 6px;
            padding: 12px;
            border-bottom: 1px solid #27272a;
        }
     
        .sidebar-header {
            padding: 12px 16px;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #71717a;
            border-bottom: 1px solid #27272a;
        }
     
        .tree-container {
            flex: 1;
            overflow-y: auto;
            padding: 8px 0;
            font-size: 13px;
        }
     
        .folder-header {
            padding: 4px 12px;
            display: flex;
            align-items: center;
            gap: 6px;
            cursor: pointer;
            user-select: none;
        }
        .folder-header:hover { background: #27272a; }
        .folder-header.active { background: #27272a; color: #bae6fd; font-weight: 500; }
     
        .toggle { display: inline-block; width: 14px; font-size: 11px; color: #71717a; }
        .tree-children { padding-left: 20px; }
     
        .file-item {
            padding: 4px 12px 4px 32px;
            cursor: pointer;
        }
        .file-item:hover,
        .file-item:focus { background: #27272a; }
        .file-item.active {
            background: #27272a !important;
            color: #bae6fd;
            font-weight: 500;
        }
     
        .editor-area { flex: 1; display: flex; flex-direction: column; min-width: 0; }
     
        .tabs {
            display: flex;
            background: #18181b;
            border-bottom: 1px solid #27272a;
            overflow-x: auto;
            flex-shrink: 0;
        }
     
        .tab {
            padding: 10px 20px 8px;
            white-space: nowrap;
            border-right: 1px solid #27272a;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
        }
        .tab.active {
            background: #09090b;
            border-bottom: 2px solid #a1a1aa;
        }
        .tab .close { margin-left: 12px; opacity: 0.6; font-size: 15px; }
        .tab .close:hover { opacity: 1; color: #e4e4e7; }
        .tab .dirty-indicator { color: #a1a1aa; font-size: 10px; margin-left: 2px; }
        .tab.drag-over { border-left: 2px solid #a1a1aa; }
        .tab[draggable] { cursor: grab; }
        .tab[draggable]:active { cursor: grabbing; }
     
        .toast {
            position: fixed;
            top: 16px;
            left: 50%;
            transform: translateX(-50%);
            background: #27272a;
            color: #e4e4e7;
            padding: 10px 24px;
            border-radius: 4px;
            font-size: 13px;
            z-index: 9999;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
        }
     
        .editor-wrapper {
            flex: 1;
            display: flex;
            position: relative;
            background: #0a0a0b;
            overflow: hidden;
        }
     
        #gutter {
            width: 52px;
            background: #0f0f11;
            color: #52525b;
            text-align: right;
            padding: 12px 8px 0 0;
            user-select: none;
            font-family: ui-monospace, monospace;
            font-size: 14px;
            line-height: 1.6;
            overflow: hidden;
            border-right: 1px solid #1f1f22;
            flex-shrink: 0;
        }
     
        #textarea {
            flex: 1;
            background: transparent;
            border: none;
            outline: none;
            color: #e4e4e7;
            font-family: ui-monospace, monospace;
            font-size: 14px;
            line-height: 1.6;
            padding: 12px 16px;
            resize: none;
            overflow: auto;
            white-space: pre;
            tab-size: 4;
        }
     
        .status {
            height: 28px;
            background: #18181b;
            border-top: 1px solid #27272a;
            font-size: 12px;
            color: #52525b;
            display: flex;
            align-items: center;
            padding: 0 16px;
            font-family: ui-monospace, monospace;
        }
     
        .sidebar-toggle {
            background: none;
            border: none;
            color: #a1a1aa;
            font-size: 22px;
            line-height: 1;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
            font-weight: 400;
            transition: color 0.2s;
        }
        .sidebar-toggle:hover { background: #27272a; color: #e4e4e7; }
     
        .context-menu {
            position: fixed;
            background: #18181b;
            border: 1px solid #27272a;
            border-radius: 4px;
            padding: 4px 0;
            z-index: 10000;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
            min-width: 180px;
        }
        .context-menu-item {
            padding: 8px 16px;
            cursor: pointer;
            font-size: 13px;
            color: #e4e4e7;
        }
        .context-menu-item:hover { background: #27272a; }
        .context-menu-item.submenu-header {
            padding: 8px 16px 4px;
            color: #71717a;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            cursor: default;
        }
        .context-menu-item.sub {
            padding-left: 40px;
        }
        .context-menu-item.danger { color: #ef4444; }
        .context-menu-item.danger:hover { background: #7f1d1d; }
        .context-menu-separator {
            height: 1px;
            background: #27272a;
            margin: 4px 0;
        }
     
        .line-length {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            color: #71717a;
            padding: 0 12px;
            border-left: 1px solid #27272a;
            border-right: 1px solid #27272a;
            height: 100%;
        }
        .line-length span { font-weight: 500; }
        #line-slider {
            accent-color: #e4e4e7;
            width: 110px;
        }
        #line-value {
            font-family: ui-monospace, monospace;
            min-width: 24px;
            text-align: right;
        }
        /* Mobile responsive styles */
        @media (max-width: 768px) {
            .line-length span { display: none; }
            #line-slider { width: 70px; }
        }
    </style>
</head>
<body>
    <div class="topbar">
        <button class="sidebar-toggle" id="sidebar-toggle" onclick="toggleSidebar()" title="Toggle Sidebar">›</button>
        <div class="logo">EDITOR</div>
        <button class="sidebar-toggle" id="menu-btn" onclick="toggleActionsDropdown()" title="Actions">⋮</button>
        <div style="flex:1"></div>
      
        <!-- Line length control -->
        <div class="line-length">
            <span>Line</span>
            <input type="range" id="line-slider" min="45" max="75" value="66">
            <span id="line-value">66</span>
        </div>
      
        <div id="status" class="status">Ready</div>
    </div>
    <div class="main">
        <div id="sidebar" class="sidebar">
            <div id="sidebar-header" class="sidebar-header">Directory</div>
            <div id="tree-container" class="tree-container"></div>
            <div style="padding:12px;border-top:1px solid #27272a;font-size:11px;color:#52525b;cursor:pointer" onclick="clearSavedFolder()">
                Clear saved folder
            </div>
        </div>
        <div class="editor-area">
            <div id="tabs" class="tabs"></div>
            <div class="editor-wrapper">
                <div id="gutter"></div>
                <textarea id="textarea" spellcheck="false" autocapitalize="none" autocomplete="off"></textarea>
            </div>
            <div id="editor-status" class="status">No file open</div>
        </div>
    </div>
    
<script>
        // Core state
        let currentDirHandle = null;
        let fileTree = null;
        let tabs = [];
        let currentTabId = null;
        let nextTabId = 1;
        let db = null;
        let expandedFolders = new Set();
        let contextMenu = null;
        let contextMenuTarget = null;
        let actionsDropdown = null;
        let maxCharsPerLine = 66;
        let enforcingLineBreaks = false;

        // New state for active/highlight
        let activeFilePath = null;
        let activeFolderPath = null;
        let targetDirHandle = null;

        const textarea = document.getElementById('textarea');
        const gutter = document.getElementById('gutter');
        const tabsContainer = document.getElementById('tabs');
        const treeContainer = document.getElementById('tree-container');
        const sidebarHeader = document.getElementById('sidebar-header');
        const sidebarEl = document.getElementById('sidebar');
        const statusEl = document.getElementById('status');
        const editorStatusEl = document.getElementById('editor-status');

        const TEXT_FILE_EXTENSIONS = /\.(txt|md|js|ts|html|css|json|py|go|rs|jsx|tsx|vue|xml|yaml|yml|toml|sh|bash|sql)$/i;
        const PROSE_EXTENSIONS = /\.(txt|md|markdown|rst|org|tex|adoc|asciidoc)$/i;
        const INVALID_FILENAME_CHARS = /[<>:"|?*\x00-\x1F]/;

        // ─────────────────────────────────────────────────────────────
        // Line length slider + smart row-break (prose only)
        // ─────────────────────────────────────────────────────────────
        function setupLineLengthControl() {
            const slider = document.getElementById('line-slider');
            const valueEl = document.getElementById('line-value');
          
            slider.value = maxCharsPerLine;
            valueEl.textContent = maxCharsPerLine;
          
            slider.addEventListener('input', () => {
                maxCharsPerLine = parseInt(slider.value);
                valueEl.textContent = maxCharsPerLine;
                const currentTab = tabs.find(t => t.id === currentTabId);
                if (currentTab && PROSE_EXTENSIONS.test(currentTab.name)) {
                    reflowAllText();
                }
            });
        }

        // ─────────────────────────────────────────────────────────────
        // Markdown structure detection helpers
        // ─────────────────────────────────────────────────────────────
        function isStructuralLine(line) {
            const trimmed = line.trimStart();
            if (trimmed === '') return false;
            
            // Headings: # Title
            if (/^#{1,6}\s/.test(trimmed)) return true;
            
            // Unordered lists: - item, * item, + item
            if (/^[-*+]\s/.test(trimmed)) return true;
            
            // Ordered lists: 1. item, 2) item
            if (/^\d+[.)]\s/.test(trimmed)) return true;
            
            // Block quotes: > text
            if (/^>\s?/.test(trimmed)) return true;
            
            // Horizontal rules: ---, ***, ___
            if (/^([-*_])\1{2,}$/.test(trimmed)) return true;
            
            // Fenced code blocks: ```, ~~~
            if (/^```|^~~~/.test(trimmed)) return true;
            
            // Indented code blocks (4+ spaces or tab)
            if (/^(    |\t)/.test(line)) return true;
            
            return false;
        }

        function enforceLineBreaks() {
            if (enforcingLineBreaks || !maxCharsPerLine) return;
            enforcingLineBreaks = true;
            const cursor = textarea.selectionStart;
            let text = textarea.value;
            let lineStart = text.lastIndexOf('\n', cursor - 1) + 1;
            let lineEnd = text.indexOf('\n', cursor);
            if (lineEnd === -1) lineEnd = text.length;
            let currentLine = text.substring(lineStart, lineEnd);
            let changed = false;
            let newCursor = cursor;

            // Don't reflow structural lines
            if (isStructuralLine(currentLine)) {
                enforcingLineBreaks = false;
                return;
            }

            // Merge from next line (only if not structural)
            while (currentLine.length < maxCharsPerLine) {
                let nextLineEnd = text.indexOf('\n', lineEnd + 1);
                if (nextLineEnd === -1) nextLineEnd = text.length;
                if (lineEnd >= text.length) break;
                const nextLine = text.substring(lineEnd + 1, nextLineEnd);
                if (nextLine.length === 0) break;
                // Don't merge structural lines
                if (isStructuralLine(nextLine)) break;
                
                const space = currentLine.length === 0 ? '' : ' ';
                const remaining = maxCharsPerLine - currentLine.length - space.length;
                if (remaining <= 0) break;
                const spaceIdx = nextLine.indexOf(' ');
                const firstWord = spaceIdx === -1 ? nextLine : nextLine.substring(0, spaceIdx);
                if (firstWord.length > remaining) break;

                if (spaceIdx === -1) {
                    currentLine += space + nextLine;
                    text = text.substring(0, lineEnd) + space + nextLine + text.substring(nextLineEnd);
                } else {
                    currentLine += space + firstWord;
                    const rest = nextLine.substring(spaceIdx + 1);
                    text = text.substring(0, lineEnd) + space + firstWord + '\n' + rest + text.substring(nextLineEnd);
                }
                changed = true;
                lineEnd = text.indexOf('\n', lineStart + currentLine.length) || text.length;
            }

            // Split if still too long (improved logic to avoid mid-word breaks)
            if (currentLine.length > maxCharsPerLine) {
                let breakPos = currentLine.lastIndexOf(' ', maxCharsPerLine);
                // Only fall back to hard break if no space found at all
                if (breakPos === -1) {
                    breakPos = maxCharsPerLine;
                }
                const before = currentLine.substring(0, breakPos);
                let after = currentLine.substring(breakPos).trimStart();
                text = text.substring(0, lineStart) + before + '\n' + after + text.substring(lineEnd);
                if (newCursor > lineStart + breakPos) {
                    newCursor = lineStart + before.length + 1;
                }
                changed = true;
            }

            if (changed) {
                textarea.value = text;
                textarea.selectionStart = textarea.selectionEnd = newCursor;
                updateLineNumbers();
            }
            enforcingLineBreaks = false;
        }
      
        function reflowAllText() {
            if (!maxCharsPerLine) return;
            const cursor = textarea.selectionStart;
            const lines = textarea.value.split('\n');
            const reflowed = [];
            let i = 0;
            let inCodeBlock = false;
          
            while (i < lines.length) {
                const line = lines[i];
                const trimmed = line.trimStart();
                
                // Toggle code block state on fence markers
                if (/^```|^~~~/.test(trimmed)) {
                    inCodeBlock = !inCodeBlock;
                    reflowed.push(line);
                    i++;
                    continue;
                }
                
                // Inside code blocks: preserve everything as-is
                if (inCodeBlock) {
                    reflowed.push(line);
                    i++;
                    continue;
                }
                
                // Empty lines: preserve
                if (trimmed === '') {
                    reflowed.push(line);
                    i++;
                    continue;
                }
                
                // Structural lines: preserve as-is
                if (isStructuralLine(line)) {
                    reflowed.push(line);
                    i++;
                    continue;
                }
                
                // Regular paragraph: collect and reflow
                let para = line;
                i++;
                while (i < lines.length && lines[i].trim() !== '' && !isStructuralLine(lines[i])) {
                    para += ' ' + lines[i];
                    i++;
                }
                
                // Reflow the paragraph with improved line breaking
                while (para.length > maxCharsPerLine) {
                    let breakPos = para.lastIndexOf(' ', maxCharsPerLine);
                    // Only fall back to hard break if no space found at all
                    if (breakPos === -1) {
                        breakPos = maxCharsPerLine;
                    }
                    reflowed.push(para.substring(0, breakPos));
                    para = para.substring(breakPos).trimStart();
                }
                if (para.length > 0) {
                    reflowed.push(para);
                }
            }
          
            textarea.value = reflowed.join('\n');
            textarea.selectionStart = textarea.selectionEnd = Math.min(cursor, textarea.value.length);
            updateLineNumbers();
        }

        // ─────────────────────────────────────────────────────────────
        // Active file & folder highlighting
        // ─────────────────────────────────────────────────────────────
        async function getDirectoryHandleByPath(path) {
            if (!path || path === '') return currentDirHandle;
            const parts = path.split('/');
            let handle = currentDirHandle;
            for (const part of parts) {
                if (part) handle = await handle.getDirectoryHandle(part);
            }
            return handle;
        }

        async function setActiveFromPath(path) {
            activeFilePath = path;
            const parentPath = path.includes('/') ? path.substring(0, path.lastIndexOf('/')) : '';
            activeFolderPath = parentPath;
            targetDirHandle = await getDirectoryHandleByPath(parentPath);
            highlightActiveItems();
        }

        function highlightActiveItems() {
            document.querySelectorAll('.file-item.active, .folder-header.active').forEach(el => el.classList.remove('active'));
            if (activeFilePath) {
                const fileEl = treeContainer.querySelector(`.file-item[data-path="${activeFilePath}"]`);
                if (fileEl) fileEl.classList.add('active');
            }
            if (activeFolderPath) {
                const folderEl = treeContainer.querySelector(`.folder-header[data-path="${activeFolderPath}"]`);
                if (folderEl) folderEl.classList.add('active');
            }
        }

        // ─────────────────────────────────────────────────────────────
        // Menu
        // ─────────────────────────────────────────────────────────────
        function toggleActionsDropdown() {
            if (actionsDropdown) { closeActionsDropdown(); return; }
            closeContextMenu();

            actionsDropdown = document.createElement('div');
            actionsDropdown.className = 'context-menu';
            actionsDropdown.innerHTML = `
                <div class="context-menu-item submenu-header">New</div>
                <div class="context-menu-item sub" onclick="handleAction('newFile')">File</div>
                <div class="context-menu-item sub" onclick="handleAction('newFolder')">Folder</div>
                <div class="context-menu-separator"></div>
                <div class="context-menu-item submenu-header">Open</div>
                <div class="context-menu-item sub" onclick="handleAction('openFile')">File</div>
                <div class="context-menu-item sub" onclick="handleAction('openFolder')">Folder</div>
                <div class="context-menu-separator"></div>
                <div class="context-menu-item" onclick="handleAction('saveCurrentFile')">Save (Ctrl+S)</div>
                <div class="context-menu-item" onclick="handleAction('saveAs')">Save As…</div>
            `;

            const btnRect = document.getElementById('menu-btn').getBoundingClientRect();
            actionsDropdown.style.position = 'fixed';
            actionsDropdown.style.top = `${btnRect.bottom + 4}px`;
            actionsDropdown.style.left = `${btnRect.left}px`;
            document.body.appendChild(actionsDropdown);
        }

        function handleAction(action) {
            closeActionsDropdown();
            switch (action) {
                case 'openFolder': openFolder(); break;
                case 'openFile': openFile(); break;
                case 'newFile': newFile(); break;
                case 'newFolder': newFolder(); break;
                case 'saveCurrentFile': saveCurrentFile(); break;
                case 'saveAs': saveAsCurrentFile(); break;
            }
        }

        function closeActionsDropdown() {
            if (actionsDropdown) {
                actionsDropdown.remove();
                actionsDropdown = null;
            }
        }

        // ─────────────────────────────────────────────────────────────
        // Save As…
        // ─────────────────────────────────────────────────────────────
        async function saveAsCurrentFile() {
            if (currentTabId === null) return;
            const tab = tabs.find(t => t.id === currentTabId);
            if (!tab) return;

            try {
                const content = (currentTabId === tab.id) ? textarea.value : tab.content;
                const newHandle = await window.showSaveFilePicker({ suggestedName: tab.name });
                const writable = await newHandle.createWritable();
                await writable.write(content);
                await writable.close();

                // Update current tab to the new file
                tab.handle = newHandle;
                tab.name = newHandle.name;
                tab.content = content;
                tab.dirty = false;

                if (tab.element) {
                    tab.element.querySelector('.tab-name').textContent = newHandle.name;
                    tab.element.querySelector('.dirty-indicator').style.display = 'none';
                }

                updateEditorStatus(tab);
                showToast(`Saved as ${newHandle.name}`);

                // Clear tree highlight (Save As may be outside current folder)
                activeFilePath = null;
                highlightActiveItems();
            } catch (err) {
                if (err.name !== 'AbortError') showToast('Save As failed');
            }
        }
    
        function toggleSidebar() {
            sidebarEl.classList.toggle('hidden');
            updateSidebarToggle();
        }

        function updateSidebarToggle() {
            const btn = document.getElementById('sidebar-toggle');
            if (!btn) return;
            const isHidden = sidebarEl.classList.contains('hidden');
            btn.textContent = isHidden ? '<' : '>';
            btn.title = isHidden ? 'Expand Sidebar' : 'Collapse Sidebar';
        }
       
        function showToast(message, duration = 3000) {
            const toast = document.createElement('div');
            toast.className = 'toast';
            toast.textContent = message;
            document.body.appendChild(toast);
            setTimeout(() => toast.remove(), duration);
        }
        function showContextMenu(e, node, isFolder) {
            e.preventDefault();
            e.stopPropagation();
            closeContextMenu();
           
            contextMenuTarget = node;
            contextMenu = document.createElement('div');
            contextMenu.className = 'context-menu';
           
            if (isFolder) {
                contextMenu.innerHTML = `
                    <div class="context-menu-item" onclick="renameItem()">Rename</div>
                    <div class="context-menu-separator"></div>
                    <div class="context-menu-item danger" onclick="deleteFolder()">Delete Folder</div>
                `;
            } else {
                contextMenu.innerHTML = `
                    <div class="context-menu-item" onclick="openFileFromNode(contextMenuTarget)">Open</div>
                    <div class="context-menu-item" onclick="renameItem()">Rename</div>
                    <div class="context-menu-separator"></div>
                    <div class="context-menu-item danger" onclick="deleteFile()">Delete File</div>
                `;
            }
           
            contextMenu.style.left = e.pageX + 'px';
            contextMenu.style.top = e.pageY + 'px';
            document.body.appendChild(contextMenu);
           
            const rect = contextMenu.getBoundingClientRect();
            if (rect.right > window.innerWidth) {
                contextMenu.style.left = (window.innerWidth - rect.width - 4) + 'px';
            }
            if (rect.bottom > window.innerHeight) {
                contextMenu.style.top = (window.innerHeight - rect.height - 4) + 'px';
            }
        }
        function closeContextMenu() {
            if (contextMenu) {
                contextMenu.remove();
                contextMenu = null;
                contextMenuTarget = null;
            }
        }
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.context-menu') && !e.target.closest('#menu-btn')) {
                closeContextMenu();
                closeActionsDropdown();
            }
        });
        document.addEventListener('contextmenu', (e) => {
            if (!e.target.closest('.file-item') && !e.target.closest('.folder-header')) {
                closeContextMenu();
            }
        });
        async function initDB() {
            return new Promise(resolve => {
                const req = indexedDB.open('FileEditor', 1);
                req.onupgradeneeded = e => e.target.result.createObjectStore('handles');
                req.onsuccess = e => { db = e.target.result; resolve(); };
                req.onerror = e => { console.error('IndexedDB error:', e); resolve(); };
            });
        }
        async function saveFolderHandle(handle) {
            if (!db) await initDB();
            try {
                const tx = db.transaction('handles', 'readwrite');
                tx.objectStore('handles').put(handle, 'main');
            } catch (e) {
                console.error('Failed to save folder handle:', e);
            }
        }
        async function loadSavedFolder() {
            if (!db) await initDB();
            try {
                const tx = db.transaction('handles');
                const store = tx.objectStore('handles');
                const request = store.get('main');
               
                request.onsuccess = async () => {
                    if (!request.result) return;
                   
                    const handle = request.result;
                    try {
                        let permission = await handle.queryPermission({ mode: 'readwrite' });
                        if (permission !== 'granted') {
                            permission = await handle.requestPermission({ mode: 'readwrite' });
                        }
                        if (permission === 'granted') {
                            currentDirHandle = handle;
                            await buildAndRenderTree();
                        } else {
                            showToast('Permission denied for saved folder');
                            await clearSavedFolder();
                        }
                    } catch (err) {
                        showToast('Saved folder no longer accessible');
                        await clearSavedFolder();
                    }
                };
            } catch (e) {
                console.error('Error in loadSavedFolder:', e);
            }
        }
        function loadExpandedState() {
            try {
                const saved = localStorage.getItem('expandedFolders');
                if (saved) expandedFolders = new Set(JSON.parse(saved));
            } catch (e) {
                console.error('Failed to load expanded state:', e);
            }
        }
        function saveExpandedState() {
            try {
                localStorage.setItem('expandedFolders', JSON.stringify([...expandedFolders]));
            } catch (e) {
                console.error('Failed to save expanded state:', e);
            }
        }
        async function isSameEntry(h1, h2) {
            if (!h1 || !h2) return false;
            if (h1.isSameEntry) {
                try {
                    return await h1.isSameEntry(h2);
                } catch (e) {
                    console.error('isSameEntry failed:', e);
                }
            }
            try {
                if (h1.kind === 'file' && h2.kind === 'file') {
                    const file1 = await h1.getFile();
                    const file2 = await h2.getFile();
                    return file1.name === file2.name &&
                           file1.size === file2.size &&
                           file1.lastModified === file2.lastModified;
                }
                return h1.name === h2.name && h1.kind === h2.kind;
            } catch {
                return false;
            }
        }
        async function buildTree(dirHandle, basePath = '', maxDepth = 10, currentDepth = 0) {
            const node = {
                name: dirHandle.name,
                kind: 'directory',
                handle: dirHandle,
                path: basePath,
                children: [],
                truncated: false
            };
            if (currentDepth >= maxDepth) {
                node.truncated = true;
                return node;
            }
            try {
                for await (const [name, handle] of dirHandle.entries()) {
                    if (name.startsWith('.') || name === 'node_modules' || name === '__pycache__') {
                        continue;
                    }
                    const childPath = basePath ? `${basePath}/${name}` : name;
                   
                    if (handle.kind === 'directory') {
                        const childNode = await buildTree(handle, childPath, maxDepth, currentDepth + 1);
                        node.children.push(childNode);
                    } else {
                        node.children.push({
                            name: name,
                            kind: 'file',
                            handle: handle,
                            path: childPath,
                            ext: name.split('.').pop().toLowerCase()
                        });
                    }
                }
                node.children.sort((a, b) => {
                    if (a.kind !== b.kind) return a.kind === 'directory' ? -1 : 1;
                    return a.name.localeCompare(b.name, undefined, { numeric: true });
                });
            } catch (err) {
                console.error('Error building tree:', err);
                showToast('Error reading directory: ' + dirHandle.name);
            }
            return node;
        }
        async function buildAndRenderTree() {
            if (!currentDirHandle) return;
            try {
                fileTree = await buildTree(currentDirHandle);
                sidebarHeader.textContent = `Directory: ${fileTree.name}`;
                renderTree();
            } catch (err) {
                showToast('Failed to build directory tree: ' + err.message);
            }
        }
        function renderTree() {
            treeContainer.innerHTML = '';
            if (!fileTree) return;
            fileTree.children.forEach(child => {
                renderTreeItem(child, treeContainer, 0);
            });
        }
        function renderTreeItem(node, parentEl, level) {
            if (node.kind === 'directory') {
                const folderDiv = document.createElement('div');
                folderDiv.className = 'tree-folder';
               
                const header = document.createElement('div');
                header.className = 'folder-header';
                header.dataset.path = node.path;
                header.style.paddingLeft = `${level * 14}px`;
                header.tabIndex = 0;
               
                const toggle = document.createElement('span');
                toggle.className = 'toggle';
                toggle.textContent = expandedFolders.has(node.path) ? '▼' : '▶';
               
                header.appendChild(toggle);
                header.appendChild(document.createTextNode(' ' + node.name));
               
                const childrenDiv = document.createElement('div');
                childrenDiv.className = 'tree-children';
                childrenDiv.style.display = expandedFolders.has(node.path) ? 'block' : 'none';
               
                header.onclick = () => toggleFolder(node, header, childrenDiv);
                header.addEventListener('keydown', e => handleTreeKeydown(e, node, header, childrenDiv));
                header.addEventListener('contextmenu', e => showContextMenu(e, node, true));
               
                folderDiv.appendChild(header);
                folderDiv.appendChild(childrenDiv);
                parentEl.appendChild(folderDiv);
               
                node.children.forEach(child => renderTreeItem(child, childrenDiv, level + 1));
            } else {
                const fileDiv = document.createElement('div');
                fileDiv.className = 'file-item';
                fileDiv.dataset.path = node.path;
                fileDiv.style.paddingLeft = `${level * 14 + 26}px`;
                fileDiv.textContent = node.name;
                fileDiv.tabIndex = 0;
                fileDiv.onclick = () => openFileFromNode(node);
                fileDiv.addEventListener('keydown', e => {
                    if (e.key === 'Enter') { e.preventDefault(); openFileFromNode(node); }
                    else navigateTree(e);
                });
                fileDiv.addEventListener('contextmenu', e => showContextMenu(e, node, false));
                parentEl.appendChild(fileDiv);
            }
        }
        function toggleFolder(node, header, childrenDiv) {
            const isOpen = childrenDiv.style.display !== 'none';
            childrenDiv.style.display = isOpen ? 'none' : 'block';
           
            const toggle = header.querySelector('.toggle');
            toggle.textContent = isOpen ? '▶' : '▼';
           
            if (isOpen) {
                expandedFolders.delete(node.path);
            } else {
                expandedFolders.add(node.path);
            }
            saveExpandedState();

            activeFolderPath = node.path;
            targetDirHandle = node.handle;
            highlightActiveItems();
        }
        function getVisibleTreeItems() {
            return Array.from(treeContainer.querySelectorAll('.folder-header, .file-item'))
                .filter(el => el.offsetParent !== null);
        }
        function navigateTree(e) {
            const items = getVisibleTreeItems();
            const idx = items.indexOf(e.target);
            if (idx === -1) return;
            if (e.key === 'ArrowDown' && idx < items.length - 1) {
                e.preventDefault();
                items[idx + 1].focus();
            } else if (e.key === 'ArrowUp' && idx > 0) {
                e.preventDefault();
                items[idx - 1].focus();
            }
        }
        function handleTreeKeydown(e, node, header, childrenDiv) {
            if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                toggleFolder(node, header, childrenDiv);
            } else if (e.key === 'ArrowRight') {
                e.preventDefault();
                if (childrenDiv.style.display === 'none') {
                    toggleFolder(node, header, childrenDiv);
                } else {
                    const firstChild = childrenDiv.querySelector('.folder-header, .file-item');
                    if (firstChild) firstChild.focus();
                }
            } else if (e.key === 'ArrowLeft') {
                e.preventDefault();
                if (childrenDiv.style.display !== 'none') {
                    toggleFolder(node, header, childrenDiv);
                } else {
                    const parentChildren = header.closest('.tree-children');
                    if (parentChildren) {
                        const parentHeader = parentChildren.previousElementSibling;
                        if (parentHeader) parentHeader.focus();
                    }
                }
            } else {
                navigateTree(e);
            }
        }
        async function openFolder() {
            try {
                currentDirHandle = await window.showDirectoryPicker();
                await saveFolderHandle(currentDirHandle);
                expandedFolders.clear();
                await buildAndRenderTree();
            } catch (err) {
                if (err.name !== 'AbortError') {
                    showToast('Failed to open folder: ' + err.message);
                }
            }
        }
        async function openFile() {
            try {
                const [handle] = await window.showOpenFilePicker();
                const file = await handle.getFile();
                const content = await file.text();
                createNewTab(handle, file.name, content);
            } catch (err) {
                if (err.name !== 'AbortError') {
                    showToast('Failed to open file: ' + err.message);
                }
            }
        }
        async function newFile() {
            if (!currentDirHandle) {
                showToast('Open a folder first to create a new file');
                return;
            }
            const name = prompt('Enter new file name:');
            if (!name || !name.trim()) return;
            const trimmed = name.trim();
            if (INVALID_FILENAME_CHARS.test(trimmed) || trimmed === '.' || trimmed === '..' || /[\/\\]/.test(trimmed)) {
                showToast('Invalid filename');
                return;
            }
            const dirHandle = targetDirHandle || currentDirHandle;
            try {
                let exists = false;
                try {
                    await dirHandle.getFileHandle(trimmed);
                    exists = true;
                } catch (e) { }
                if (exists) {
                    showToast('File already exists');
                    return;
                }
                const fileHandle = await dirHandle.getFileHandle(trimmed, { create: true });
                const writable = await fileHandle.createWritable();
                await writable.write('');
                await writable.close();
                const filePath = activeFolderPath ? `${activeFolderPath}/${trimmed}` : trimmed;
                createNewTab(fileHandle, trimmed, '', filePath);
                await buildAndRenderTree();
                statusEl.textContent = 'Created ' + trimmed;
                setTimeout(() => statusEl.textContent = 'Ready', 2000);
            } catch (err) {
                if (err.name !== 'AbortError') {
                    showToast('Failed to create file: ' + err.message);
                }
            }
        }
        async function newFolder() {
            if (!currentDirHandle) {
                showToast('Open a folder first to create a new folder');
                return;
            }
            const name = prompt('Enter new folder name:');
            if (!name || !name.trim()) return;
            const trimmed = name.trim();
            if (INVALID_FILENAME_CHARS.test(trimmed) || trimmed === '.' || trimmed === '..' || /[\/\\]/.test(trimmed)) {
                showToast('Invalid folder name');
                return;
            }
            const dirHandle = targetDirHandle || currentDirHandle;
            try {
                let exists = false;
                try {
                    await dirHandle.getDirectoryHandle(trimmed);
                    exists = true;
                } catch (e) { }
                if (exists) {
                    showToast('Folder already exists');
                    return;
                }
                await dirHandle.getDirectoryHandle(trimmed, { create: true });
                await buildAndRenderTree();
                statusEl.textContent = 'Created folder ' + trimmed;
                setTimeout(() => statusEl.textContent = 'Ready', 2000);
            } catch (err) {
                if (err.name !== 'AbortError') {
                    showToast('Failed to create folder: ' + err.message);
                }
            }
        }
        async function deleteFile() {
            if (!contextMenuTarget || contextMenuTarget.kind !== 'file') return;
           
            const fileName = contextMenuTarget.name;
            if (!confirm(`Delete "${fileName}"? This cannot be undone.`)) {
                closeContextMenu();
                return;
            }
            try {
                for (const t of tabs) {
                    if (t.handle && await isSameEntry(t.handle, contextMenuTarget.handle)) {
                        closeTab(t.id);
                        break;
                    }
                }
                const pathParts = contextMenuTarget.path.split('/');
                pathParts.pop();
               
                let parentHandle = currentDirHandle;
                for (const part of pathParts) {
                    if (part) {
                        parentHandle = await parentHandle.getDirectoryHandle(part);
                    }
                }
               
                await parentHandle.removeEntry(fileName);
                await buildAndRenderTree();
                showToast(`Deleted ${fileName}`);
            } catch (err) {
                showToast('Failed to delete file: ' + err.message);
            } finally {
                closeContextMenu();
            }
        }
        async function deleteFolder() {
            if (!contextMenuTarget || contextMenuTarget.kind !== 'directory') return;
           
            const folderName = contextMenuTarget.name;
            if (contextMenuTarget.children && contextMenuTarget.children.length > 0) {
                showToast('Cannot delete non-empty folder');
                closeContextMenu();
                return;
            }
            if (!confirm(`Delete empty folder "${folderName}"?`)) {
                closeContextMenu();
                return;
            }
            try {
                const pathParts = contextMenuTarget.path.split('/');
                pathParts.pop();
               
                let parentHandle = currentDirHandle;
                for (const part of pathParts) {
                    if (part) {
                        parentHandle = await parentHandle.getDirectoryHandle(part);
                    }
                }
               
                await parentHandle.removeEntry(folderName);
                expandedFolders.delete(contextMenuTarget.path);
                saveExpandedState();
                await buildAndRenderTree();
                showToast(`Deleted folder ${folderName}`);
            } catch (err) {
                showToast('Failed to delete folder: ' + err.message);
            } finally {
                closeContextMenu();
            }
        }
        async function renameItem() {
            if (!contextMenuTarget) return;
           
            const oldName = contextMenuTarget.name;
            const isFolder = contextMenuTarget.kind === 'directory';
            const newName = prompt(`Rename ${isFolder ? 'folder' : 'file'}:`, oldName);
           
            if (!newName || !newName.trim() || newName === oldName) {
                closeContextMenu();
                return;
            }
            const trimmed = newName.trim();
            if (INVALID_FILENAME_CHARS.test(trimmed) || trimmed === '.' || trimmed === '..' || /[\/\\]/.test(trimmed)) {
                showToast('Invalid name');
                closeContextMenu();
                return;
            }
            try {
                const pathParts = contextMenuTarget.path.split('/');
                pathParts.pop();
               
                let parentHandle = currentDirHandle;
                for (const part of pathParts) {
                    if (part) {
                        parentHandle = await parentHandle.getDirectoryHandle(part);
                    }
                }
                try {
                    if (isFolder) {
                        await parentHandle.getDirectoryHandle(trimmed);
                    } else {
                        await parentHandle.getFileHandle(trimmed);
                    }
                    showToast('Name already exists');
                    closeContextMenu();
                    return;
                } catch (e) { }
                if (isFolder) {
                    showToast('Folder renaming not yet implemented');
                } else {
                    const oldHandle = await parentHandle.getFileHandle(oldName);
                    const file = await oldHandle.getFile();
                    const content = await file.text();
                   
                    const newHandle = await parentHandle.getFileHandle(trimmed, { create: true });
                    const writable = await newHandle.createWritable();
                    await writable.write(content);
                    await writable.close();
                   
                    await parentHandle.removeEntry(oldName);
                   
                    for (const openTab of tabs) {
                        if (openTab.handle && await isSameEntry(openTab.handle, contextMenuTarget.handle)) {
                            openTab.name = trimmed;
                            openTab.handle = newHandle;
                            if (openTab.element) {
                                const nameSpan = openTab.element.querySelector('.tab-name');
                                if (nameSpan) nameSpan.textContent = trimmed;
                            }
                            updateEditorStatus(openTab);
                            break;
                        }
                    }
                   
                    await buildAndRenderTree();
                    showToast(`Renamed to ${trimmed}`);
                }
            } catch (err) {
                showToast('Failed to rename: ' + err.message);
            } finally {
                closeContextMenu();
            }
        }
        async function openFileFromNode(node) {
            try {
                const file = await node.handle.getFile();
                if (!file.type.startsWith('text/') && !TEXT_FILE_EXTENSIONS.test(file.name)) {
                    if (!confirm('This looks like a binary file. Open anyway?')) return;
                }
                const content = await file.text();
                createNewTab(node.handle, node.name, content, node.path);
            } catch (err) {
                showToast('Failed to open file: ' + err.message);
            }
        }
        async function createNewTab(handle, name, content = '', path = null) {
            if (handle) {
                for (const t of tabs) {
                    if (t.handle && await isSameEntry(t.handle, handle)) {
                        switchToTab(t.id);
                        return;
                    }
                }
            }
            const id = nextTabId++;
            const tab = { id, name, handle, content, dirty: false, path };
            tabs.push(tab);
           
            const tabEl = document.createElement('div');
            tabEl.className = 'tab';
            tabEl.dataset.id = id;
            tabEl.draggable = true;

            tabEl.addEventListener('dragstart', e => {
                e.dataTransfer.setData('text/plain', id);
                tabEl.style.opacity = '0.5';
            });
            tabEl.addEventListener('dragend', () => {
                tabEl.style.opacity = '';
                document.querySelectorAll('.tab.drag-over').forEach(t => t.classList.remove('drag-over'));
            });
            tabEl.addEventListener('dragover', e => {
                e.preventDefault();
                document.querySelectorAll('.tab.drag-over').forEach(t => t.classList.remove('drag-over'));
                tabEl.classList.add('drag-over');
            });
            tabEl.addEventListener('dragleave', () => tabEl.classList.remove('drag-over'));
            tabEl.addEventListener('drop', e => {
                e.preventDefault();
                tabEl.classList.remove('drag-over');
                const draggedId = parseInt(e.dataTransfer.getData('text/plain'), 10);
                if (draggedId === id) return;
                const fromIdx = tabs.findIndex(t => t.id === draggedId);
                const toIdx = tabs.findIndex(t => t.id === id);
                if (fromIdx === -1 || toIdx === -1) return;
                const [moved] = tabs.splice(fromIdx, 1);
                tabs.splice(toIdx, 0, moved);
                const draggedEl = tabsContainer.querySelector(`.tab[data-id="${draggedId}"]`);
                if (draggedEl) tabsContainer.insertBefore(draggedEl, tabEl);
            });
           
            const nameSpan = document.createElement('span');
            nameSpan.className = 'tab-name';
            nameSpan.textContent = name;
           
            const dirtyIndicator = document.createElement('span');
            dirtyIndicator.className = 'dirty-indicator';
            dirtyIndicator.style.display = 'none';
            dirtyIndicator.textContent = ' *';
           
            const closeBtn = document.createElement('span');
            closeBtn.className = 'close';
            closeBtn.textContent = '×';
            closeBtn.onclick = (e) => { e.stopPropagation(); closeTab(id); };
           
            tabEl.appendChild(nameSpan);
            tabEl.appendChild(dirtyIndicator);
            tabEl.appendChild(closeBtn);
            tabEl.onclick = () => switchToTab(id);
           
            tabsContainer.appendChild(tabEl);
            tab.element = tabEl;
           
            switchToTab(id);
        }
        function switchToTab(id) {
            if (currentTabId !== null) {
                const current = tabs.find(t => t.id === currentTabId);
                if (current) {
                    current.content = textarea.value;
                }
            }
           
            currentTabId = id;
            const tab = tabs.find(t => t.id === id);
           
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelector(`.tab[data-id="${id}"]`)?.classList.add('active');
           
            textarea.value = tab.content;
            updateLineNumbers();
            updateEditorStatus(tab);

            if (tab.path) {
                setActiveFromPath(tab.path);
            } else {
                activeFilePath = null;
                activeFolderPath = null;
                highlightActiveItems();
            }
        }
        function closeTab(id) {
            const idx = tabs.findIndex(t => t.id === id);
            if (idx === -1) return;
           
            const tab = tabs[idx];
            if (currentTabId === id) {
                tab.content = textarea.value;
            }
           
            if (tab.dirty) {
                if (!confirm(`"${tab.name}" has unsaved changes. Close anyway?`)) {
                    return;
                }
            }
           
            tabs.splice(idx, 1);
            const tabEl = document.querySelector(`.tab[data-id="${id}"]`);
            if (tabEl) tabEl.remove();
           
            if (tabs.length === 0) {
                currentTabId = null;
                textarea.value = '';
                gutter.innerHTML = '';
                editorStatusEl.textContent = 'No file open';
                return;
            }
           
            const nextIdx = Math.min(idx, tabs.length - 1);
            switchToTab(tabs[nextIdx].id);
        }
        function updateLineNumbers() {
            const lines = textarea.value.split('\n').length;
            let html = '';
            for (let i = 1; i <= lines; i++) html += i + '<br>';
            gutter.innerHTML = html;
        }
        function syncScroll() {
            gutter.scrollTop = textarea.scrollTop;
        }
        textarea.addEventListener('keydown', e => {
            if (e.key === 'Tab') {
                e.preventDefault();
                const start = textarea.selectionStart;
                const end = textarea.selectionEnd;
                const indent = '    ';
                textarea.value = textarea.value.substring(0, start) + indent + textarea.value.substring(end);
                textarea.selectionStart = textarea.selectionEnd = start + indent.length;
                textarea.dispatchEvent(new Event('input', { bubbles: true }));
            }
        });
       
        let saveTimer;
        function scheduleSave() {
            clearTimeout(saveTimer);
            const tabIdToSave = currentTabId;
            saveTimer = setTimeout(() => {
                if (tabIdToSave !== null) {
                    const tab = tabs.find(t => t.id === tabIdToSave);
                    if (tab && tab.dirty) {
                        if (currentTabId === tabIdToSave) {
                            tab.content = textarea.value;
                        }
                        saveTab(tab);
                    }
                }
            }, 800);
        }
        // Auto line break on typing (prose files only)
        textarea.addEventListener('input', () => {
            const tab = tabs.find(t => t.id === currentTabId);
            if (tab && PROSE_EXTENSIONS.test(tab.name)) {
                enforceLineBreaks();
            }
        });
        textarea.addEventListener('input', () => {
            updateLineNumbers();
            if (currentTabId !== null) {
                const tab = tabs.find(t => t.id === currentTabId);
                if (tab) {
                    tab.dirty = true;
                    if (tab.element) {
                        const indicator = tab.element.querySelector('.dirty-indicator');
                        if (indicator) indicator.style.display = '';
                    }
                    updateEditorStatus(tab);
                    scheduleSave();
                }
            }
        });
        textarea.addEventListener('scroll', () => gutter.scrollTop = textarea.scrollTop);
        async function saveTab(tab) {
            if (!tab || !tab.handle) return;
            if (!tab.dirty) return;
           
            try {
                const writable = await tab.handle.createWritable();
                const content = (currentTabId === tab.id) ? textarea.value : tab.content;
                await writable.write(content);
                await writable.close();
                tab.content = content;
                tab.dirty = false;
                if (tab.element) {
                    const indicator = tab.element.querySelector('.dirty-indicator');
                    if (indicator) indicator.style.display = 'none';
                }
                updateEditorStatus(tab);
                statusEl.textContent = 'Saved';
                setTimeout(() => statusEl.textContent = 'Ready', 1200);
            } catch (err) {
                showToast('Save failed: ' + err.message);
            }
        }
        async function saveCurrentFile() {
            if (currentTabId === null) return;
            const tab = tabs.find(t => t.id === currentTabId);
            await saveTab(tab);
        }
        function updateEditorStatus(tab) {
            editorStatusEl.textContent = tab.name + (tab.dirty ? ' • Modified' : '');
        }
        let searchPanel = null;
        let searchMatches = [];
        let currentMatchIndex = -1;
        function showSearchPanel() {
            if (searchPanel) {
                document.getElementById('search-input').focus();
                return;
            }
            searchPanel = document.createElement('div');
            searchPanel.className = 'search-panel';
           
            const input = document.createElement('input');
            input.type = 'text';
            input.id = 'search-input';
            input.placeholder = 'Search...';
           
            const matchCount = document.createElement('span');
            matchCount.className = 'match-count';
            matchCount.id = 'match-count';
            matchCount.textContent = '0 matches';
           
            const nextBtn = document.createElement('button');
            nextBtn.textContent = 'Next';
            nextBtn.addEventListener('click', findNext);
           
            const prevBtn = document.createElement('button');
            prevBtn.textContent = 'Previous';
            prevBtn.addEventListener('click', findPrevious);
           
            const closeBtn = document.createElement('button');
            closeBtn.className = 'close-search';
            closeBtn.textContent = '×';
            closeBtn.addEventListener('click', closeSearch);
           
            searchPanel.appendChild(input);
            searchPanel.appendChild(matchCount);
            searchPanel.appendChild(nextBtn);
            searchPanel.appendChild(prevBtn);
            searchPanel.appendChild(closeBtn);
            document.body.appendChild(searchPanel);
            input.focus();
            input.addEventListener('input', performSearch);
            input.addEventListener('keydown', e => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    if (e.shiftKey) {
                        findPrevious();
                    } else {
                        findNext();
                    }
                } else if (e.key === 'Escape') {
                    closeSearch();
                }
            });
        }
        function performSearch() {
            const query = document.getElementById('search-input').value;
            searchMatches = [];
            currentMatchIndex = -1;
            if (!query || !textarea.value) {
                document.getElementById('match-count').textContent = '0 matches';
                return;
            }
            const text = textarea.value;
            const lowerText = text.toLowerCase();
            const lowerQuery = query.toLowerCase();
           
            let pos = 0;
            while ((pos = lowerText.indexOf(lowerQuery, pos)) !== -1) {
                searchMatches.push(pos);
                pos += query.length;
            }
            document.getElementById('match-count').textContent = `${searchMatches.length} matches`;
           
            if (searchMatches.length > 0) {
                currentMatchIndex = 0;
                highlightMatch();
            }
        }
        function findNext() {
            if (searchMatches.length === 0) return;
            currentMatchIndex = (currentMatchIndex + 1) % searchMatches.length;
            highlightMatch();
        }
        function findPrevious() {
            if (searchMatches.length === 0) return;
            currentMatchIndex = (currentMatchIndex - 1 + searchMatches.length) % searchMatches.length;
            highlightMatch();
        }
        function highlightMatch() {
            if (currentMatchIndex < 0 || currentMatchIndex >= searchMatches.length) return;
           
            const pos = searchMatches[currentMatchIndex];
            const query = document.getElementById('search-input').value;
           
            textarea.focus();
            textarea.setSelectionRange(pos, pos + query.length);
            textarea.scrollTop = textarea.scrollHeight * (pos / textarea.value.length) - textarea.clientHeight / 2;
           
            document.getElementById('match-count').textContent =
                `${currentMatchIndex + 1} of ${searchMatches.length}`;
        }
        function closeSearch() {
            if (searchPanel) {
                searchPanel.remove();
                searchPanel = null;
                searchMatches = [];
                currentMatchIndex = -1;
            }
        }
        // Global keyboard shortcuts
        document.addEventListener('keydown', e => {
            if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                e.preventDefault();
                saveCurrentFile();
            } else if ((e.ctrlKey || e.metaKey) && e.key === 'f') {
                e.preventDefault();
                showSearchPanel();
            } else if ((e.ctrlKey || e.metaKey) && e.key === 'w') {
                e.preventDefault();
                if (currentTabId !== null) closeTab(currentTabId);
            }
        });
       
        window.addEventListener('beforeunload', e => {
            const hasUnsaved = tabs.some(t => t.dirty);
            if (hasUnsaved) {
                e.preventDefault();
            }
        });
        async function clearSavedFolder() {
            if (db) {
                try {
                    const tx = db.transaction('handles', 'readwrite');
                    tx.objectStore('handles').delete('main');
                } catch (e) {
                    console.error('Failed to clear saved folder:', e);
                }
            }
            currentDirHandle = null;
            fileTree = null;
            treeContainer.innerHTML = '';
            sidebarHeader.textContent = 'Directory';
            expandedFolders.clear();
            localStorage.removeItem('expandedFolders');
            showToast('Saved folder cleared');
        }
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('sw.js')
                .then(() => console.log('Service Worker registered'))
                .catch(err => console.log('SW registration failed', err));
        }
window.onload = async () => {
            await initDB();
            loadExpandedState();
            await loadSavedFolder();

            // Mobile: collapse sidebar, adjust line slider range
            const isMobile = window.innerWidth <= 768;
            if (isMobile) {
                sidebarEl.classList.add('hidden');
                const slider = document.getElementById('line-slider');
                slider.min = 30;
                slider.max = 45;
                slider.value = 38;
                maxCharsPerLine = 38;
                document.getElementById('line-value').textContent = '38';
            }

            setupLineLengthControl();
            updateSidebarToggle();
           
            if (tabs.length === 0) {
                createNewTab(null, 'welcome.txt', 'EDITOR is ready.\n\nType. Break. Ship.\n\n66 characters feels right.');
            }
        };
    </script>
</body>
</html>
