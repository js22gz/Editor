<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EDITOR</title>
   
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#18181b">
 
    <style>
        * { box-sizing: border-box; }
        body {
            margin: 0;
            height: 100vh;
            background: #09090b;
            color: #e4e4e7;
            font-family: system-ui, -apple-system, sans-serif;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
       
        .topbar {
            height: 52px;
            background: #18181b;
            border-bottom: 1px solid #27272a;
            display: flex;
            align-items: center;
            padding: 0 16px;
            gap: 12px;
            flex-shrink: 0;
        }
       
        .logo { font-weight: 700; font-size: 20px; letter-spacing: -0.5px; }
       
        .btn {
            background: #27272a;
            color: #e4e4e7;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .btn:hover { background: #3f3f46; }
        .btn.accent {
            background: #d4d4d8;
            color: black;
            font-weight: 600;
        }
        .btn.accent:hover { background: #e4e4e7; }
       
        .main { flex: 1; display: flex; overflow: hidden; }
       
        .sidebar {
            width: 280px;
            background: #111113;
            border-right: 1px solid #27272a;
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
            transition: width 0.2s, opacity 0.2s;
            overflow: hidden;
        }
        .sidebar.hidden {
            width: 0;
            border-right: none;
            opacity: 0;
            pointer-events: none;
        }
        .sidebar-buttons {
            display: flex;
            flex-direction: column;
            gap: 6px;
            padding: 12px;
            border-bottom: 1px solid #27272a;
        }
       
        .sidebar-header {
            padding: 12px 16px;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #71717a;
            border-bottom: 1px solid #27272a;
        }
       
        .tree-container {
            flex: 1;
            overflow-y: auto;
            padding: 8px 0;
            font-size: 13px;
        }
       
        .folder-header {
            padding: 4px 12px;
            display: flex;
            align-items: center;
            gap: 6px;
            cursor: pointer;
            user-select: none;
        }
        .folder-header:hover { background: #27272a; }
       
        .toggle { display: inline-block; width: 14px; font-size: 11px; color: #71717a; }
        .tree-children { padding-left: 20px; }
       
        .file-item {
            padding: 4px 12px 4px 32px;
            cursor: pointer;
        }
        .file-item:hover, .file-item:focus { background: #27272a; }
       
        .editor-area { flex: 1; display: flex; flex-direction: column; min-width: 0; }
       
        .tabs {
            display: flex;
            background: #18181b;
            border-bottom: 1px solid #27272a;
            overflow-x: auto;
            flex-shrink: 0;
        }
       
        .tab {
            padding: 10px 20px 8px;
            white-space: nowrap;
            border-right: 1px solid #27272a;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
        }
        .tab.active {
            background: #09090b;
            border-bottom: 2px solid #a1a1aa;
        }
        .tab .close { margin-left: 12px; opacity: 0.6; font-size: 15px; }
        .tab .close:hover { opacity: 1; color: #e4e4e7; }
        .tab .dirty-indicator { color: #a1a1aa; font-size: 10px; margin-left: 2px; }
       
        .toast {
            position: fixed;
            top: 16px;
            left: 50%;
            transform: translateX(-50%);
            background: #27272a;
            color: #e4e4e7;
            padding: 10px 24px;
            border-radius: 4px;
            font-size: 13px;
            z-index: 9999;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
        }
       
        .editor-wrapper {
            flex: 1;
            display: flex;
            position: relative;
            background: #0a0a0b;
            overflow: hidden;
        }
       
        #gutter {
            width: 52px;
            background: #0f0f11;
            color: #52525b;
            text-align: right;
            padding: 12px 8px 0 0;
            user-select: none;
            font-family: ui-monospace, monospace;
            font-size: 14px;
            line-height: 1.6;
            overflow: hidden;
            border-right: 1px solid #1f1f22;
            flex-shrink: 0;
        }
       
        #textarea {
            flex: 1;
            background: transparent;
            border: none;
            outline: none;
            color: #e4e4e7;
            font-family: ui-monospace, monospace;
            font-size: 14px;
            line-height: 1.6;
            padding: 12px 16px;
            resize: none;
            overflow: auto;
            white-space: pre;
            tab-size: 4;
        }
       
        .status {
            height: 28px;
            background: #18181b;
            border-top: 1px solid #27272a;
            font-size: 12px;
            color: #52525b;
            display: flex;
            align-items: center;
            padding: 0 16px;
            font-family: ui-monospace, monospace;
        }
       
        .sidebar-toggle {
            background: none;
            border: none;
            color: #a1a1aa;
            font-size: 18px;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
        }
        .sidebar-toggle:hover { background: #27272a; color: #e4e4e7; }
       
        .context-menu {
            position: fixed;
            background: #18181b;
            border: 1px solid #27272a;
            border-radius: 4px;
            padding: 4px 0;
            z-index: 10000;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
            min-width: 160px;
        }
        .context-menu-item {
            padding: 8px 16px;
            cursor: pointer;
            font-size: 13px;
            color: #e4e4e7;
        }
        .context-menu-item:hover { background: #27272a; }
        .context-menu-item.danger { color: #ef4444; }
        .context-menu-item.danger:hover { background: #7f1d1d; }
        .context-menu-separator {
            height: 1px;
            background: #27272a;
            margin: 4px 0;
        }
       
        .line-length {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            color: #71717a;
            padding: 0 12px;
            border-left: 1px solid #27272a;
            border-right: 1px solid #27272a;
            height: 100%;
        }
        .line-length span { font-weight: 500; }
        #line-slider {
            accent-color: #e4e4e7;
            width: 110px;
        }
        #line-value {
            font-family: ui-monospace, monospace;
            min-width: 24px;
            text-align: right;
        }
    </style>
</head>
<body>
    <div class="topbar">
        <button class="sidebar-toggle" onclick="toggleSidebar()" title="Toggle Sidebar">☰</button>
        <div class="logo">EDITOR</div>
        <div style="flex:1"></div>
        
        <!-- Line length control -->
        <div class="line-length">
            <span>Line</span>
            <input type="range" id="line-slider" min="45" max="75" value="66">
            <span id="line-value">66</span>
        </div>
        
        <div id="status" class="status">Ready</div>
    </div>
    <div class="main">
        <div id="sidebar" class="sidebar">
            <div class="sidebar-buttons">
                <button class="btn" onclick="openFolder()">Open Folder</button>
                <button class="btn" onclick="openFile()">Open File</button>
                <button class="btn" onclick="newFile()">New File</button>
                <button class="btn" onclick="newFolder()">New Folder</button>
                <button class="btn accent" onclick="saveCurrentFile()">Save (Ctrl+S)</button>
            </div>
            <div id="sidebar-header" class="sidebar-header">Directory</div>
            <div id="tree-container" class="tree-container"></div>
            <div style="padding:12px;border-top:1px solid #27272a;font-size:11px;color:#52525b;cursor:pointer" onclick="clearSavedFolder()">
                Clear saved folder
            </div>
        </div>
        <div class="editor-area">
            <div id="tabs" class="tabs"></div>
            <div class="editor-wrapper">
                <div id="gutter"></div>
                <textarea id="textarea" spellcheck="false" autocapitalize="none" autocomplete="off"></textarea>
            </div>
            <div id="editor-status" class="status">No file open</div>
        </div>
    </div>

    <script>
        // Core state
        let currentDirHandle = null;
        let fileTree = null;
        let tabs = [];
        let currentTabId = null;
        let nextTabId = 1;
        let db = null;
        let expandedFolders = new Set();
        let contextMenu = null;
        let contextMenuTarget = null;
        let maxCharsPerLine = 66;

        const textarea = document.getElementById('textarea');
        const gutter = document.getElementById('gutter');
        const tabsContainer = document.getElementById('tabs');
        const treeContainer = document.getElementById('tree-container');
        const sidebarHeader = document.getElementById('sidebar-header');
        const sidebarEl = document.getElementById('sidebar');
        const statusEl = document.getElementById('status');
        const editorStatusEl = document.getElementById('editor-status');

        const TEXT_FILE_EXTENSIONS = /\.(txt|md|js|ts|html|css|json|py|go|rs|jsx|tsx|vue|xml|yaml|yml|toml|sh|bash|sql)$/i;
        const INVALID_FILENAME_CHARS = /[<>:"|?*\x00-\x1F]/;

        // ─────────────────────────────────────────────────────────────
        // Line length slider + auto row-break
        // ─────────────────────────────────────────────────────────────
        function setupLineLengthControl() {
            const slider = document.getElementById('line-slider');
            const valueEl = document.getElementById('line-value');
            
            slider.value = maxCharsPerLine;
            valueEl.textContent = maxCharsPerLine;
            
            slider.addEventListener('input', () => {
                maxCharsPerLine = parseInt(slider.value);
                valueEl.textContent = maxCharsPerLine;
            });
        }

        function enforceLineBreaks(e) {
            if (!maxCharsPerLine) return;
            
            const start = textarea.selectionStart;
            const text = textarea.value;
            
            // Find current line boundaries
            const lineStart = text.lastIndexOf('\n', start - 1) + 1;
            let lineEnd = text.indexOf('\n', start);
            if (lineEnd === -1) lineEnd = text.length;
            
            const currentLine = text.substring(lineStart, lineEnd);
            
            if (currentLine.length <= maxCharsPerLine) return;
            
            // Find best break point (last space before limit)
            let breakPos = currentLine.lastIndexOf(' ', maxCharsPerLine);
            if (breakPos === -1 || breakPos < 10) breakPos = maxCharsPerLine;
            
            const before = currentLine.substring(0, breakPos);
            let after = currentLine.substring(breakPos).trimStart();
            
            const newLine = before + '\n' + after;
            const newText = text.substring(0, lineStart) + newLine + text.substring(lineEnd);
            
            textarea.value = newText;
            
            // Place cursor at start of new line
            const newCursor = lineStart + before.length + 1;
            textarea.selectionStart = textarea.selectionEnd = newCursor;
            
            updateLineNumbers();
        }

        // ─────────────────────────────────────────────────────────────
        // Rest of the code (unchanged except minor cleanups)
        // ─────────────────────────────────────────────────────────────
        function toggleSidebar() { sidebarEl.classList.toggle('hidden'); }

        function showToast(message, duration = 4000) {
            const toast = document.createElement('div');
            toast.className = 'toast';
            toast.textContent = message;
            document.body.appendChild(toast);
            setTimeout(() => toast.remove(), duration);
        }

        // ─────────────────────────────────────────────────────────────
        // IndexedDB for persisting folder handle
        // ─────────────────────────────────────────────────────────────
        function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('EditorDB', 1);
                request.onupgradeneeded = e => {
                    const d = e.target.result;
                    if (!d.objectStoreNames.contains('state')) {
                        d.createObjectStore('state');
                    }
                };
                request.onsuccess = e => { db = e.target.result; resolve(); };
                request.onerror = e => { console.error('Failed to open IndexedDB', e); resolve(); };
            });
        }

        function dbPut(key, value) {
            if (!db) return;
            const tx = db.transaction('state', 'readwrite');
            tx.objectStore('state').put(value, key);
        }

        function dbGet(key) {
            return new Promise(resolve => {
                if (!db) return resolve(undefined);
                const tx = db.transaction('state', 'readonly');
                const req = tx.objectStore('state').get(key);
                req.onsuccess = () => resolve(req.result);
                req.onerror = () => resolve(undefined);
            });
        }

        function dbDelete(key) {
            if (!db) return;
            const tx = db.transaction('state', 'readwrite');
            tx.objectStore('state').delete(key);
        }

        // ─────────────────────────────────────────────────────────────
        // Line numbers
        // ─────────────────────────────────────────────────────────────
        function updateLineNumbers() {
            const lines = textarea.value.split('\n');
            gutter.innerHTML = lines.map((_, i) => i + 1).join('<br>');
            gutter.scrollTop = textarea.scrollTop;
        }

        // ─────────────────────────────────────────────────────────────
        // Tab management
        // ─────────────────────────────────────────────────────────────
        function createNewTab(handle, name, content) {
            const id = nextTabId++;
            tabs.push({ id, handle, name, content, dirty: false });
            switchTab(id);
            renderTabs();
            return id;
        }

        function switchTab(id) {
            const tab = tabs.find(t => t.id === id);
            if (!tab) return;
            // Save current tab content
            if (currentTabId !== null) {
                const cur = tabs.find(t => t.id === currentTabId);
                if (cur) cur.content = textarea.value;
            }
            currentTabId = id;
            textarea.value = tab.content || '';
            updateLineNumbers();
            renderTabs();
            updateEditorStatus();
        }

        function closeTab(id) {
            const idx = tabs.findIndex(t => t.id === id);
            if (idx === -1) return;
            const tab = tabs[idx];
            if (tab.dirty) {
                if (!confirm(`"${tab.name}" has unsaved changes. Close anyway?`)) return;
            }
            tabs.splice(idx, 1);
            if (tabs.length === 0) {
                currentTabId = null;
                textarea.value = '';
                updateLineNumbers();
            } else if (currentTabId === id) {
                const next = tabs[Math.min(idx, tabs.length - 1)];
                switchTab(next.id);
            }
            renderTabs();
            updateEditorStatus();
        }

        function renderTabs() {
            tabsContainer.innerHTML = '';
            tabs.forEach(tab => {
                const el = document.createElement('div');
                el.className = 'tab' + (tab.id === currentTabId ? ' active' : '');
                el.innerHTML = `
                    <span>${tab.name}</span>
                    ${tab.dirty ? '<span class="dirty-indicator">●</span>' : ''}
                    <span class="close" data-id="${tab.id}">&times;</span>
                `;
                el.addEventListener('click', e => {
                    if (e.target.classList.contains('close')) {
                        closeTab(parseInt(e.target.dataset.id));
                    } else {
                        switchTab(tab.id);
                    }
                });
                tabsContainer.appendChild(el);
            });
        }

        function markDirty() {
            if (currentTabId === null) return;
            const tab = tabs.find(t => t.id === currentTabId);
            if (tab && !tab.dirty) {
                tab.dirty = true;
                renderTabs();
            }
        }

        function updateEditorStatus() {
            if (currentTabId === null) {
                editorStatusEl.textContent = 'No file open';
            } else {
                const tab = tabs.find(t => t.id === currentTabId);
                if (tab) {
                    const lines = textarea.value.split('\n').length;
                    editorStatusEl.textContent = `${tab.name} — ${lines} line${lines !== 1 ? 's' : ''}`;
                }
            }
        }

        // ─────────────────────────────────────────────────────────────
        // File operations
        // ─────────────────────────────────────────────────────────────
        async function openFolder() {
            try {
                currentDirHandle = await window.showDirectoryPicker();
                dbPut('dirHandle', currentDirHandle);
                await buildTree();
            } catch (e) {
                if (e.name !== 'AbortError') console.error(e);
            }
        }

        async function openFile() {
            try {
                const [handle] = await window.showOpenFilePicker({
                    multiple: false,
                    types: [{ description: 'Text Files', accept: { 'text/*': ['.txt', '.md', '.js', '.ts', '.html', '.css', '.json', '.py', '.go', '.rs'] } }]
                });
                const file = await handle.getFile();
                const content = await file.text();
                createNewTab(handle, file.name, content);
            } catch (e) {
                if (e.name !== 'AbortError') console.error(e);
            }
        }

        function newFile() {
            const name = prompt('File name:');
            if (!name) return;
            if (INVALID_FILENAME_CHARS.test(name)) {
                showToast('Invalid file name');
                return;
            }
            createNewTab(null, name, '');
        }

        async function newFolder() {
            if (!currentDirHandle) {
                showToast('Open a folder first');
                return;
            }
            const name = prompt('Folder name:');
            if (!name) return;
            if (INVALID_FILENAME_CHARS.test(name)) {
                showToast('Invalid folder name');
                return;
            }
            try {
                await currentDirHandle.getDirectoryHandle(name, { create: true });
                await buildTree();
                showToast(`Folder "${name}" created`);
            } catch (e) {
                showToast('Failed to create folder');
                console.error(e);
            }
        }

        async function saveCurrentFile() {
            if (currentTabId === null) return;
            const tab = tabs.find(t => t.id === currentTabId);
            if (!tab) return;
            tab.content = textarea.value;

            if (tab.handle) {
                try {
                    const writable = await tab.handle.createWritable();
                    await writable.write(tab.content);
                    await writable.close();
                    tab.dirty = false;
                    renderTabs();
                    showToast(`Saved ${tab.name}`);
                } catch (e) {
                    showToast('Failed to save');
                    console.error(e);
                }
            } else {
                try {
                    const handle = await window.showSaveFilePicker({
                        suggestedName: tab.name,
                        types: [{ description: 'Text Files', accept: { 'text/plain': ['.txt'] } }]
                    });
                    const writable = await handle.createWritable();
                    await writable.write(tab.content);
                    await writable.close();
                    tab.handle = handle;
                    tab.name = handle.name;
                    tab.dirty = false;
                    renderTabs();
                    showToast(`Saved ${tab.name}`);
                } catch (e) {
                    if (e.name !== 'AbortError') {
                        showToast('Failed to save');
                        console.error(e);
                    }
                }
            }
            updateEditorStatus();
        }

        // ─────────────────────────────────────────────────────────────
        // File tree
        // ─────────────────────────────────────────────────────────────
        async function buildTree() {
            if (!currentDirHandle) return;
            sidebarHeader.textContent = currentDirHandle.name;
            fileTree = await readDir(currentDirHandle, '');
            renderTree();
        }

        async function readDir(dirHandle, path) {
            const entries = [];
            for await (const entry of dirHandle.values()) {
                const entryPath = path ? path + '/' + entry.name : entry.name;
                if (entry.kind === 'file') {
                    entries.push({ kind: 'file', name: entry.name, handle: entry, path: entryPath });
                } else if (entry.kind === 'directory') {
                    const children = await readDir(entry, entryPath);
                    entries.push({ kind: 'directory', name: entry.name, handle: entry, path: entryPath, children });
                }
            }
            entries.sort((a, b) => {
                if (a.kind !== b.kind) return a.kind === 'directory' ? -1 : 1;
                return a.name.localeCompare(b.name);
            });
            return entries;
        }

        function renderTree() {
            treeContainer.innerHTML = '';
            if (fileTree) {
                treeContainer.appendChild(renderTreeLevel(fileTree));
            }
        }

        function renderTreeLevel(entries) {
            const fragment = document.createDocumentFragment();
            entries.forEach(entry => {
                if (entry.kind === 'directory') {
                    const div = document.createElement('div');
                    const expanded = expandedFolders.has(entry.path);
                    const header = document.createElement('div');
                    header.className = 'folder-header';
                    header.innerHTML = `<span class="toggle">${expanded ? '▾' : '▸'}</span>${entry.name}`;
                    header.addEventListener('click', () => {
                        if (expandedFolders.has(entry.path)) {
                            expandedFolders.delete(entry.path);
                        } else {
                            expandedFolders.add(entry.path);
                        }
                        saveExpandedState();
                        renderTree();
                    });
                    header.addEventListener('contextmenu', e => {
                        e.preventDefault();
                        showContextMenu(e.clientX, e.clientY, entry);
                    });
                    div.appendChild(header);
                    if (expanded && entry.children) {
                        const childDiv = document.createElement('div');
                        childDiv.className = 'tree-children';
                        childDiv.appendChild(renderTreeLevel(entry.children));
                        div.appendChild(childDiv);
                    }
                    fragment.appendChild(div);
                } else {
                    const item = document.createElement('div');
                    item.className = 'file-item';
                    item.textContent = entry.name;
                    item.tabIndex = 0;
                    item.addEventListener('click', () => openTreeFile(entry));
                    item.addEventListener('keydown', e => { if (e.key === 'Enter') openTreeFile(entry); });
                    item.addEventListener('contextmenu', e => {
                        e.preventDefault();
                        showContextMenu(e.clientX, e.clientY, entry);
                    });
                    fragment.appendChild(item);
                }
            });
            return fragment;
        }

        async function openTreeFile(entry) {
            // Check if already open
            const existing = tabs.find(t => t.handle === entry.handle);
            if (existing) {
                switchTab(existing.id);
                return;
            }
            try {
                const file = await entry.handle.getFile();
                if (!TEXT_FILE_EXTENSIONS.test(file.name)) {
                    showToast('Not a supported text file');
                    return;
                }
                const content = await file.text();
                createNewTab(entry.handle, file.name, content);
            } catch (e) {
                showToast('Failed to open file');
                console.error(e);
            }
        }

        // ─────────────────────────────────────────────────────────────
        // Expanded state persistence
        // ─────────────────────────────────────────────────────────────
        function saveExpandedState() {
            try {
                localStorage.setItem('editor-expanded', JSON.stringify([...expandedFolders]));
            } catch (e) { console.warn('localStorage unavailable', e); }
        }

        function loadExpandedState() {
            try {
                const saved = localStorage.getItem('editor-expanded');
                if (saved) expandedFolders = new Set(JSON.parse(saved));
            } catch (e) { console.warn('localStorage unavailable', e); }
        }

        async function loadSavedFolder() {
            try {
                const handle = await dbGet('dirHandle');
                if (handle) {
                    const permission = await handle.queryPermission({ mode: 'readwrite' });
                    if (permission === 'granted') {
                        currentDirHandle = handle;
                        await buildTree();
                    } else {
                        const req = await handle.requestPermission({ mode: 'readwrite' });
                        if (req === 'granted') {
                            currentDirHandle = handle;
                            await buildTree();
                        }
                    }
                }
            } catch (e) {
                console.error('Failed to load saved folder', e);
            }
        }

        function clearSavedFolder() {
            dbDelete('dirHandle');
            currentDirHandle = null;
            fileTree = null;
            treeContainer.innerHTML = '';
            sidebarHeader.textContent = 'Directory';
            showToast('Saved folder cleared');
        }

        // ─────────────────────────────────────────────────────────────
        // Context menu
        // ─────────────────────────────────────────────────────────────
        function showContextMenu(x, y, entry) {
            hideContextMenu();
            contextMenuTarget = entry;
            contextMenu = document.createElement('div');
            contextMenu.className = 'context-menu';
            contextMenu.style.left = x + 'px';
            contextMenu.style.top = y + 'px';

            if (entry.kind === 'file') {
                addContextMenuItem('Open', () => openTreeFile(entry));
                addContextMenuSeparator();
                addContextMenuItem('Delete', async () => {
                    if (!confirm(`Delete "${entry.name}"?`)) return;
                    try {
                        const parent = currentDirHandle;
                        await parent.removeEntry(entry.name);
                        await buildTree();
                        showToast(`Deleted "${entry.name}"`);
                    } catch (e) {
                        showToast('Failed to delete');
                        console.error(e);
                    }
                }, true);
            } else {
                addContextMenuItem('New File Here', async () => {
                    const name = prompt('File name:');
                    if (!name || INVALID_FILENAME_CHARS.test(name)) return;
                    try {
                        await entry.handle.getFileHandle(name, { create: true });
                        await buildTree();
                    } catch (e) {
                        showToast('Failed to create file');
                        console.error(e);
                    }
                });
                addContextMenuItem('New Subfolder', async () => {
                    const name = prompt('Folder name:');
                    if (!name || INVALID_FILENAME_CHARS.test(name)) return;
                    try {
                        await entry.handle.getDirectoryHandle(name, { create: true });
                        await buildTree();
                    } catch (e) {
                        showToast('Failed to create folder');
                        console.error(e);
                    }
                });
            }

            document.body.appendChild(contextMenu);
        }

        function addContextMenuItem(label, onClick, danger) {
            const item = document.createElement('div');
            item.className = 'context-menu-item' + (danger ? ' danger' : '');
            item.textContent = label;
            item.addEventListener('click', () => { hideContextMenu(); onClick(); });
            contextMenu.appendChild(item);
        }

        function addContextMenuSeparator() {
            const sep = document.createElement('div');
            sep.className = 'context-menu-separator';
            contextMenu.appendChild(sep);
        }

        function hideContextMenu() {
            if (contextMenu) {
                contextMenu.remove();
                contextMenu = null;
                contextMenuTarget = null;
            }
        }

        document.addEventListener('click', () => hideContextMenu());

        // ─────────────────────────────────────────────────────────────
        // Search panel (minimal find in editor)
        // ─────────────────────────────────────────────────────────────
        function showSearchPanel() {
            const query = prompt('Find:');
            if (!query) return;
            const text = textarea.value;
            const idx = text.indexOf(query, textarea.selectionEnd);
            if (idx !== -1) {
                textarea.focus();
                textarea.selectionStart = idx;
                textarea.selectionEnd = idx + query.length;
            } else {
                // Wrap around from start
                const idx2 = text.indexOf(query);
                if (idx2 !== -1) {
                    textarea.focus();
                    textarea.selectionStart = idx2;
                    textarea.selectionEnd = idx2 + query.length;
                } else {
                    showToast('Not found');
                }
            }
        }

        // Global keyboard shortcuts
        document.addEventListener('keydown', e => {
            if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                e.preventDefault();
                saveCurrentFile();
            } else if ((e.ctrlKey || e.metaKey) && e.key === 'f') {
                e.preventDefault();
                showSearchPanel();
            } else if ((e.ctrlKey || e.metaKey) && e.key === 'w') {
                e.preventDefault();
                if (currentTabId !== null) closeTab(currentTabId);
            }
        });

        // Auto line break on typing
        textarea.addEventListener('input', enforceLineBreaks);
        textarea.addEventListener('input', () => {
            updateLineNumbers();
            markDirty();
            updateEditorStatus();
        });
        textarea.addEventListener('scroll', () => gutter.scrollTop = textarea.scrollTop);

        window.onload = async () => {
            await initDB();
            loadExpandedState();
            await loadSavedFolder();
            setupLineLengthControl();
            
            if (tabs.length === 0) {
                createNewTab(null, 'welcome.txt', 'EDITOR is ready.\n\nType. Break. Ship.\n\n66 characters feels right.');
            }
        };
    </script>
</body>
</html>